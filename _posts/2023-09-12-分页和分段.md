---
title: 读书笔记 —— 分页和分段
authors: fanventory
date: 2023-09-12 15:41:00 +0800
categories: [八股文]
tags: [分页]
---

# 分页和分段
> 分页和分段的意义，分页和分段以及段页式的概念，具体运行过程，最后回顾了缺页中断。

<br>
<br>

## 动机

1. 解决内存管理带来的碎片问题，允许逻辑地址空间的进程放入内存是不连续的
2. 获得更大的虚拟内存空间

## 分页

用户程序的地址空间划分为固定大小的页，系统内存空间也划分为不同的块，页和块大小相等。可以将用户程序的任意一页放在内存的任意一块中，实现离散分配，从而获得更大的地址空间。
  
## 分段

将用户程序地址空间根据逻辑信息分成若干个大小不等的段。存储分配时，以段为单位，段与段在内存中可以不相邻接，实现离散分配。分段将程序和数据划分为逻辑上独立的地址空间，能够反映程序的逻辑结构，并有利于段的共享。

## 段页式

页式存储管理能有效地提高内存利用率（解决内存碎片），而分段存储管理能反映程序的逻辑结构并有利于段的共享。将这两种存储管理方法结合起来，就形成了段页式存储管理方式。  
段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。    

## 页表

分页的逻辑地址组成为： \<页号，页内位移>

过程：  
+ 先计算逻辑地址的页号
+ 根据页号去查页表中的对应的页框
+ 如果对应页号的状态位是无效的，则产生缺页中断，将该页加载到页框中
+ 将页框号和页内位移直接组合成物理地址

## 段表

分段的逻辑地址组成为： \<段号，段内位移>

过程：  
+ 先计算逻辑地址的段号
+ 根据段号去查段表中的基地址和段大小
+ 将基地址和段大小放入寄存器中
+ 将寄存器中的值与逻辑地址的段内位移比较
+ 如果合法，物理地址即段内位移加上基地址

## 段、页表

段页式的逻辑地址组成为： \<段号，页号，页内位移>

+ 先计算逻辑地址的段号
+ 根据段号查找段表，得到页表始址
+ 根据页号查找页表，得到页框号
+ 将页框号和页内位移直接组合成物理地址

## 区别

| 分段 | 分页 |
| -- | -- |
| 信息的逻辑单位 | 信息的物理单位 |
| 段长是任意的 | 页长是固定的 |
| 段的起始地址可以从主存任一地址开始 | 页的起始地址只能是页大小的整数倍开始 |
| (段号，段内位移)构成二维地址空间 | (页号，页内位移)构成一维地址空间 |
| 产生外部碎片 | 消除外部碎片，但出现内部碎片 |

## 缺页中断

当 CPU 访问的⻚⾯不在物理内存时，便会产⽣⼀个缺⻚中断，请求操作系统将所缺⻚调⼊到物理内存。  

常见的页面置换算法：  
+ 最佳⻚⾯置换算法(OPT)

选择以后永不使用的页面，或是在最长(未来)时间内不再被访问的页面进行淘汰。由于最佳页面置换算法很理想，实际系统中⽆法实现。

+ 先进先出置换算法(FIFO)

选择最先调入内存的页面进行置换

优点：实现简单，不需要硬件支持  
缺点：没有考虑到缓存页面被使用的情况，可能会出现Belady异常现象(可能会出现分配的页框数增多但缺页率反而提高的异常现象)

+ 最近最久未使⽤的置换算法(LRU)

选择最⻓时间没有被访问的⻚⾯进⾏置换。

优点：算法性能好，效率高  
缺点：在每次访问内存时都必须要更新整个链表

+ 时钟⻚⾯置换算法(Lock)

把所有的⻚⾯都保存在⼀个环形链表中，如果它的访问位是 0 就淘汰该⻚⾯，并把新的⻚⾯插⼊这个位置，然后把表针前移⼀个位置。如果访问位是 1 就置 0 ，并把表针前移⼀个位置，重复这个过程直到找到了⼀个访问位为 0 的⻚⾯为⽌。

+ 最不常⽤算法(LFU)

选择访问次数最少的那个⻚⾯进行淘汰。

# Reference
[1] [请你说说分段和分页](https://www.nowcoder.com/exam/interview/72944761/test?paperId=50270072&order=0)   
[2] [【操作系统基础】分段和分页](https://blog.csdn.net/m0_46606290/article/details/124420320)  
[3] [操作系统复习：12.缺页中断以及内存页面置换算法](https://blog.csdn.net/weixin_52008431/article/details/123919301)  