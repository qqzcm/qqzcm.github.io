---
title: 读书笔记 —— 多线程编程_1
authors: fanventory
date: 2023-07-12 10:25:00 +0800
categories: [Reading Notes, Linux高性能服务器编程]
tags: [C++, Pthread]
---

#  线程模型/线程库
> 本节简单介绍了关于线程的一些知识。线程是程序完成一个独立任务的完整执行序列，即一个可调度的实体。线程分为内核线程和用户线程，内核线程是内核调度的，用户线程是运行在用户空间，由线程库调度的。早期内核对线程的支持还不完备，所以早期的线程库LinuxPthreads通过进程模拟线程的方式来实现，并且引入管理线程机制来对工作线程进行管理，但这种方式容易引起语义问题，也不能利用多处理器的优势。随着内核完善，NPTL线程库应运而生，由内核负责线程的创建、结束、调度以及堆栈回收，效率更高，而且能有效利用多处理器的资源。

<br>
<br>


## 线程模型

线程：线程是程序完成一个独立任务的完整执行序列，即一个可调度的实体。  

根据运行环境和调度者身份，可以分为内核线程和用户线程。  
+ 内核线程: 运行在内核空间，由内核调度，在某些系统上也称为LWP(Light Weight Process, 轻量级进程)
+ 用户线程: 运行在用户空间，由线程库调度

当一个内核线程获得CPU的使用权时，它就加载并运行一个用户线程。所以，内核线程相对于用户线程运行的容器。  

<br>

一个进程可以拥有M个内核线程和N个用户线程，其中M <= N。在一个系统的所有进程中，M和N的比值都是固定的。按照M:N的取值，线程的实现方式可以分为三种：  
1. 完全在用户空间实现
   
这种实现方式无须内核的支持，由线程库来管理所有的执行线程(包括线程的优先级、时间片)。线程库利用longjmp来切换线程的执行，使他们看起来像“并发执行”。但本质上是内核把整个进程作为最小单位来调度。因此，这种实现方式满足N=1，即M个用户空间线程对应1个内核线程，该内核线程就是进程本身。早期的伯克利UNIX线程就是采用这种方法实现的。

+ 优点: 创建和调度线程无须内核干预，速度快，不占用额外的内核资源，所以即使一个进程创建了很多线程也不会对系统性能造成明显影响。  
+ 缺点: 对于多处理器系统，因为内核是按照最小调度单位进程来分配CPU的，所以多个线程无法运行在多个CPU上。此外，线程的优先级只对同一个进程中的线程有效，不同进程的线程之间无法比较优先级。

2. 完全由内核调度

这种实现方式将创建、调度线程的任务都交给了内核，运行在用户空间的线程无须执行管理任务。这种实现方式满足M:N = 1:1，即一个用户空间线程被映射为一个内核线程。

+ 优点: 多个线程可以运行在多个CPU上，而且不同进程的线程之间可以设置优先级。
+ 缺点: 创建和调度线程需要内核干预，速度较慢，需要占用额外的内核资源，所以创建了过多的线程会影响系统性能。

3. 双层调度(two level scheduler)

前两种实现模式的混合：内核调度M个内核线程，线程库调度N个用户线程。

+ 优点: 综合了两者的优点，不但不会过多消耗内核资源，而且线程切换速度也较快，同时还能充分利用多处理器的优势。

## Linux线程库

Linux上有两个最出名的线程库：LinuxThreads和NPTL。它们都是采用M:N = 1:1的方式实现的。

### LinuxThreads

LinuxThreads在开发时，Linux内核对线程的支持非常有限，所以其可用性、稳定性以及对POSIX兼容性都远不如NPTL。  
LinuxThreads的线程库内核线程是通过子进程来实现的，LinuxThreads通过clone系统调用(和fork功能类似)，创建子进程，并且为clone系统调用指定CLONE_THREAD标志。这种情况下，clone创建的子进程与调用进程共享相同的虚拟地址空间、文件描述符和信号处理函数，这些都是线程的特点。  
不过用进程来模拟线程也会导致很多语义问题：  
+ 每个线程拥有不同的PID，不符合POSIX规范
+ Linux信号处理是基于进程的，但是现在每个线程都必须处理信号
+ 同个进程创建的线程的用户ID、组ID来说可能不一样
+ 程序产生和核心转储文件不会包含所有线程的信息，只包含产生该核心转储文件的线程的信息
+ 每个线程都是一个进程，因此系统允许的最大线程数会变成最大进程数

LinuxThreads中有一个著名的特性：管理线程。  
管理线程是专门管理其他工作线程的线程，其作用包括： 
+ 系统发送给进程的终止信号先由管理线程接收，管理线程再给其他工作线程发送同样的信号以终止它们
+ 当终止工作线程或者工作线程主动退出时，管理线程必须等待它们结束，以避免僵尸进程
+ 如果主线程先于其他工作线程退出，则管理线程将阻塞它，直到所有工作线程都结束之后裁唤醒它
+ 回收每个线程堆栈使用的内存

管理线程的引入，增加了额外的系统开销，并且由于它只能运行在一个CPU上，所以LinuxThreads线程库不能充分发挥多处理器系统的优势。

### NPTL

NPTL是现代Linux默认使用的线程库。用户可以通过如下命令来查看当前系统所使用的线程库：  

```Shell
$ getconf GNU_LIBPTHREAD_VERSION
NPTL 2.27
```

随着软硬件发展，内核提供了更完善的线程支持。自Linux内核2.6开始，提供了真正的内核线程。新的NPTL也因此应运而生。相比LinuxThreads，NPTL的优势在于：  
+ 内核线程不再是一个进程，避免了很多语义问题
+ 摒弃了管理线程，终止线程、回收堆栈等工作都可以由内核来完成
+ 一个进程的线程可以运行在不同的CPU上，充分发挥多处理器系统的优势
+ 线程的同步由内核完成。不同进程的线程之间也可以共享互斥锁，实现跨进程的线程同步

## 总结
> + 线程是程序完成一个独立任务的完整执行序列，即一个可调度的实体
> + 根据运行环境和调度者身份，可以分为内核线程和用户线程
> + 内核线程是运行在内核空间，由内核调度的线程
> + 用户线程是运行在用户空间，由线程库调度的线程
> + 一个进程可以拥有M个内核线程和N个用户线程，按照M:N的取值，线程的实现方式可以分为三种：完全在用户空间实现、完全由内核调度、双层调度
> + Linux上有两个最出名的线程库：LinuxThreads和NPTL

# Reference
[1] 《深入解析高性能服务器编程》    