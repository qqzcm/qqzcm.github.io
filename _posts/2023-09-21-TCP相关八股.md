---
title: 读书笔记 —— TCP相关八股
authors: fanventory
date: 2023-09-20 21:30:00 +0800
categories: [八股文]
tags: [TCP]
---

# TCP
> TCP或UDP相关八股。

<br>
<br>

## TCP和UDP的区别

回答思路：

1. 首先指出TCP是面向连接的可靠传输，UDP是无连接的不可靠传输。
2. 然后针对TCP的可靠传输往下讲：TCP可靠传输的机制保证：(a)三次握手、四次挥手,(b)序列号、应答机制、超时重传,(c)流量控制、拥塞控制。而UDP是尽可能交付，没有这些保证机制。
3. 协议：
   1. TCP是面向字节流的，UDP面向报文
   2. TCP头部最少20字节，UDP8字节
4. 通信方式：TCP只支持1对1，UDP支持1对1，1对多，多对多
5. 速度：TCP速度慢，UDP速度快
6. 适用场景：TCP适合需要对数据进行精确保证的场景，UDP适合对速度有要求且允许数据部分丢失的场景

## TCP如何实现可靠传输

回答思路：  

分点作答：  
1. 三次握手、四次挥手
2. 序列号、应答机制
3. 检验和
4. 超时重传
5. 流量控制
6. 拥塞控制

## TCP流量控制

回答思路：  

1. 实现：
   1. 通过滑动窗口机制实现
   2. TCP报文头部的窗口字段决定滑动窗口大小
2. 目的：
   1. 平衡发送速率和接受速率，防止发送过快而接收端来不及接收
   2. 存储晚发先到的报文，避免丢弃
   3. 便于找到需要重传的报文
3. 扩展：
   1. 停等式协议、回退n步协议、选择重传协议

## TCP粘包问题

回答思路：  

1. 原因：TCP基于字节流，多个数据包会被连续存储在缓冲中，发送时多次请求的数据可能组合到一个数据报发送出去，而接收端不能根据区分边界区分这些请求，造成粘包。
2. 解决方法：
   1. 关闭Nagle算法，通过TCP_NODELAY选项实现
   2. 发送定长数据包
   3. 数据包末尾用特殊字符自定义边界(ftp做法：以\r\n作为边界)
   4. 在数据包头部字段增加长度(http做法，content-length指出数据包长度)
  
## UDP怎么实现可靠传输

回答思路：

1. 问题：udp没有实现可靠传输，只能在应用层实现，所以可以在应用层模拟TCP的可靠传输机制
2. 解决方法：
   1. 提供序列号
   2. 提供重传功能
   3. 提供流量控制
   4. 提供拥塞控制

## 三次握手过程

1. 第一次握手：客户端向服务器端发送连接请求报文段，报文的同步位SYN置为1，携带初始序列号seq=x，进入SYN-SENT状态。
2. 第二次握手：服务器端收到连接请求报文段后，发送确认响应。确认报文中同步位SYN和ACK都置为1，携带初始序列号seq=y，确认号是x+1，进入SYN-RECEIVED状态。
3. 客户端进程收到服务器端的确认报文，向服务器端给出确认。确认报文段的ACK置为1，确认号是y+1，而自己的序号seq=x+1。
4. 第三次握手，ACK报文段可以携带数据，但是如果不携带数据就不消耗序号。
5. 此时，TCP连接已经成功建立，A进入ESTABLISHED（已建立连接）状态。

## 两次握手可以吗？

不行。  
假设现在有一种情况，客户端发出的第一个连接请求报文段并没有丢失而是在某些网络节点上被滞留了，直到客户端和服务器端的新连接已经释放后的某个时间点，第一个连接请求报文段才到了服务器端，这时候服务器端以为客户端又发起了一次请求，于是服务器端向客户端发起了确认连接报文段，同意连接。假设不采用三次握手，这时候连接已经建立了，但是客户端并不知道这个情况，服务器端会一直等待客户端的数据报文，这样服务器端的资源就会被浪费，占用大量的资源。所以采用三次握手可以防止这种现象，保护网络和系统资源。

## 为什么前两次握手不能携带数据

如果第一次握手可以携带数据，当有人恶意攻击服务器时，会导致服务器需要花费大量时间和内存处理这些报文。  
第二次握手同理。

## 四次挥手过程

客户端和服务器端都可以主动释放连接。

1. 客户端的应用进程先向TCP发出一个连接释放报文段，然后停止发送数据报，主动关闭TCP连接。此时，释放报文段的FIN值1，序号为u，u相当于前面传输的数据报文段的最后一个字节的序号加1。进入FIN-WT-1（终止等待1）状态。
2. 服务器在收到客户端发来的连接释放报文段请求之后就发出确认，确认号ack=u+1，这个报文段自己的序号是v，v相当于之前已经传送出去的最后一个报文段的序号加1。服务器端进入CLOSE-WT（关闭等待）状态。
3. 如果服务器端也没有数据要发送给客户端了，发出的连接释放报文段，释放报文的FIN置1，序号为w，确认号ack=u+1。服务器端进入LAST-ACK（最后确认）状态，等待客户端的确认。
4. 客户端收到服务器端的连接释放请求报文段之后，必须发出确认。确认报文段中ACK置1，确认号ack=w+1，序号seq=u+1。
5. 服务器进入TIME-WT（时间等待）状态，必须等到2倍的MSL（最长报文段寿命）之后，连接才会释放。

## 为什么要等待两次MSL之后才释放？

四次挥手结束，主动关闭方进入TIME_WT状态。  
如果不等待，刚释放的端口可能会重连刚断开的服务器端口，这样依然存活在网络里的旧的TCP报文可能与新TCP连接报文冲突，造成数据冲突，为避免此种情况，必须等待2MSL时间，保证网络中存留的旧报文段全部过期。

## 拥塞控制过程

## TCP头部信息

![图片1](image/TCP相关八股_pic1.png)

## 常见的TCP连接状态

+ CLOSED: 初始状态
+ LISTEN：服务器处于监听状态
+ SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态
+ SYN_RECV：服务端收到SYN包并发送服务端的SYN包，进入此状态
+ ESTABLISH：表示建立连接，客户端发送最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态
+ FIN_WAIT_1：终止连接的一方，发送FIN报文后进入此状态，等待对方FIN
+ CLOSE_WAIT：接收到客户端FIN包之后等待关闭的阶段
+ FIN_WAIT_2：此时处于半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务端的ACK包后，进入此状态
+ LAST_ACK：服务端发送最后的ACK包后，等待客户端的ACK确认，进入此状态
+ TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在之后的2MSL时间进入此状态



# Reference
[1] [C++专业面试真题(1)](https://www.nowcoder.com/exam/interview/72944761/test?paperId=50270072&order=0)   
[2] [阿秀的学习笔记](https://interviewguide.cn/notes/03-hunting_job/02-interview/03-03-net.html#_48%E3%80%81%E5%B8%B8%E8%A7%81tcp%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B)

