---
title: 读书笔记 —— C++ 模板与泛型编程(5)
authors: fanventory
date: 2023-03-01 11:13:00 +0800
categories: [Reading Notes,C++ Primer]
tags: [C++, Reading Notes,template]
---

# 模板实参推断
> 本节我们继续探讨模板实参推断的内容。在这之前，我们简单介绍了左值和右值，以及左值引用和右值引用的知识。当模板参数为左值引用的时候，我们传入一个左值，会推断成对应的左值引用类型。当模板参数为const左值引用的时候，我们可以传递任何类型的参数。当模板参数为右值引用的时候，我们发现它也可以传递任何类型的参数。接下来我们深究原因，发现这是c++用了引用折叠，所以使得右值引用参数可以接收任何类型。如果模板参数类型为右值引用，可能会导致程序中一些逻辑实现出现意料之外的情况，我们举了一个例子说明这一点。模板参数类型为右值引用会导致编写正确的代码比较困难，但他有两个很好的应用：模板参数转发和模板重载。我们介绍了模板参数类型为右值引用，是怎么帮助模板转发参数的。最后，我们接着之前探讨的引用折叠，介绍了std::move()函数的原理。

<br>
<br>

## 左值和右值
在讲解后面的内容之前，我们先来回顾一下左值和右值的概念。  

C++11中，所有的值分为两种：`左值(lvalue)`、`右值(rvalue)`，其中右值又可以细分为`纯右值(prvalue)`、`将亡值(xvalue)`。我们先有一个感性的认识：在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。比如int a = b + c;中，变量a是有名字的，且可以取址的，所以它是左值。b + c是没有名字的，而且&(b+c)这种操作是非法的，所以它是右值。  

接着我们沿着C++的版本来了解右值：  
+ 在c语言中，右值是指不能在赋值语句左边的值。
+ 在c++98中，右值是指纯右值，即需要转换的临时变量，返回右值的表达式（比如b+c）、不跟对象关联的字面常量（比如true,2,'c'）。
+ 在c++11中，右值的定义进行了扩充，分为纯右值和将亡值。其中纯右值的定义和c++98中右值的定义相同，将亡值的则是c++11新增的跟右值引用相关的表达式。将亡值指移动其他变量的内存空间得到的值（比如右值引用操作&&的返回值，std::move的返回值），原来的值不能再被使用，而且即将销毁。

《c++ Primer》中给我们做了一个简单的归纳：当对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（内存中的位置）。

> 函数本身是有地址的，它是一个左值；但是函数的返回值，可能是左值，也可能是右值。（c++98中，函数被确立为左值）

<br>

最后我们说明：左值和右值的概念主要体现在许多运算符上。有些运算符需要左值运算对象，有些运算符需要右值运算对象；有些运算符返回左值结果，有些则返回右值结果。所以《c++ Primer》提出了一条重要的原则：需要右值的地方可以用左值来代替，但不能反过来把右值当左值使用；当一个左值被当成右值使用时，实际使用的是它的内容（值）

## 左值引用和右值引用
介绍完左值和右值，我们接下来来探讨`左值引用(lvalue reference)`和`右值引用(rvalue reference)`。
我们平时提到的`引用(reference)`都是指左值引用，其底层原理是通过指针实现的。当我们知道右值是没有指针的，因为右值不能取地址，而且右值在内存中在临时的，即将销毁的。正因为右值没有名字，所以我们提出右值引用来绑定右值的存在。右值引用采用&&符号来表示，我们来看下面例子：  
```c++
int i = 42;
int &r = i;         //  正确，左值引用绑定左值
int &r2 = i * 42;   //  错误，左值引用不能绑定右值
int &&rr = i;       //  错误，右值引用不能绑定左值
int &&rr2 = i * 42; //  正确，右值引用绑定右值

const int &r3 = i * 42; //  正确，const的左值引用绑定右值
```

我们可以看出，右值引用可以绑定到要求转换的表达式、字面常量和返回右值的表达式中，但不能绑定到一个左值上面。反过来，左值引用也不能绑定右值。但在最后一行我们发现，用const修饰的左值引用也可以绑定一个右值。于是，我们做以下实验：  
```c++
int &a = 2;       // 错误，左值引用不能绑定右值

int b = 2;        // 定义非const左值
const int &c = b; // 正确，const左值引用可以绑定非cosnt左值
const int d = 2;  // 定义const左值
const int &e = c; // 正确，const左值引用绑定到const左值
const int &f =2;  // 正确，const左值引用绑定到右值
```

我们得出结论：左值引用只能绑定非const左值；const左值引用可以绑定左值和右值(无论是否有const修饰)；右值引用只能绑定非const右值。（const右值引用没啥实际意义，这里不做探讨）  
而且const左值引用和右值引用能延长右值的生存时间。

> 关于为什么常量左值引用可以绑定右值，作者推测禁止左值引用绑定右值的原因可能是右值往往是临时变量（修改会导致未定义行为）或者字面常量（不可修改）。而const修饰的左值引用是禁止对引用的对象进行修改的，避免了这类问题。

<a id="tip_1"></a>
另外这里要主要，右值的引用是一个左值！  
```c++
int &&rr1 = 42;     //  正确，字面常量是右值
int &&rr2 = rr1;    //  错误，变量是左值
```

## 从左值引用函数参数推断类型
介绍完左值引用和右值引用，接下来我们要回到模板实参推断中，探讨模板实参中存在左值引用和右值引用的情况。  
如果一个函数参数是一个左值引用（T&）时，只能给它传递一个左值。实参可以是const，也可以不是；如果实参是const，则T会被推断为const类型：  
```c++
template <typename T> void f1(T&);  //  实参必须是一个左值

f1(i);    //  i是int类型，模板参数类型T推断为int
f1(ci);   //  i是const int类型，模板参数类型T推断为const int
f1(5);    //  错误，5是右值，不能传递给模板实参
```

<br>

如果一个函数参数是常量左值引用（const T&）时，我们可以给它传递任何实参（不论左值还是右值，const还是非const），就像上面const左值引用中我们实验结果的绑定情况一样。
```c++
template <typename T> void f2(const T&); 

f2(i);  //  i是int类型，模板参数类型T推断为int
f2(ci); //  i是const int类型，模板参数类型T推断为int
f2(5);  //  const左值引用可以绑定右值，模板参数类型T推断为int
```

这里需要注意一点，函数本身是const的，所以T的类型推断结果不会是const类型，因为const语句是函数参数类型的一部分了，即不会推断成const const int。

## 从右值引用函数参数推断类型
如果一个函数参数是一个右值引用（T&&）时，我们可以传递一个右值。
```c++
template <typename T> void f3(T&&);
f3(42); //  右值引用可以绑定右值，模板参数类型T推断为int
```

## 引用折叠和右值引用参数
到目前为止我们发现编译器会应用正常的引用绑定规则于模板参数类型上，和左、右值引用的绑定规则一样。但是当我们把左值传入右值引用的模板实参中，发现编译竟然通过了。  
```c++
template <typename T> void f3(T&&);
f3(i);  // i是int类型的左值，理论上右值T&&不能绑定左值，但是程序却正确运行
```

我们发现上面的程序能正常运行，这不符合右值引用不能绑定左值的设定。  
原来，c++在正常的绑定规则之上定义了两个例外规则。

1. 当我们将一个左值传递给一个函数的右值引用参数时，编译器会推断该模板类型参数是实参的左值引用类型。即我们传递f3()一个int类型变量时，编译器会推断T类型为int&。

2. 如果我们间接创建一个引用的引用，则这些引用形成了“折叠”  
左值引用的引用在所有情况下，引用会折叠成一个普通的左值引用类型。比如X& &会折叠成X&。  
在新标准中，折叠规则扩展到右值引用，只有在一种特殊情况下引用会折叠成右值引用。  
也就是说，给定一个类型X： 
+ X& &会折叠成X& 
+ X&& &和X& &&会折叠成X&
+ X&& &&会折叠成X&&（特殊情况）

通常我们不能做直接定义一个引用的引用，所以引用折叠只能应用于间接裁剪的引用的引用，比如类型别名或模板参数。  

<br>

所以让我们看回上面的例子，f3()传递了一个左值，函数的实例化看起来会像是这样：  
```c++
void f3<int&>(int& &&);
//  折叠后
void f3<int&>(int&);
```

所以总结一下：  
+ 如果一个函数参数是一个右值引用（T&&）时，它可以绑定一个左值
+ 这种情况下，如果实参是一个左值，则推断出来的模板实参类型将是一个左值引用，且函数参数将被实例化为一个左值引用参数（T&）  
+ 如果实参是一个左值，则推断出来的模板实参类型将是一个右值类型，函数参数将被实例化为一个右值引用参数（T&&）  

所以，如果一个函数参数是一个右值引用（T&&）时，则可以传递任意类型的实参（不论左值还是右值，const还是非const）。而且传入左值，函数参数会实例化为左值引用类型；传入右值，函数参数会被实例化为右值引用类型。

## 编写接受右值引用参数的模板函数
我们在上面介绍了右值引用的模板参数可以绑定容易类型的实参，现在我们定义一个这样的模板：  
```c++
template <typename T> void f3(T&& val)
{
    T t=val;
    t=fcn(t);
    if(val==t){...}
}
```

我们来观察一下这个函数模板，传入左值和传入右值有什么区别？  
当我们传入左值，比如传入int类型变量i：
+ 类型T会实例化为int&
+ 第一行代码变成int& t=val,t是一个引用
+ 第二行代码t=fcn(t)，val的值也会发生变化（因为t是引用）
+ 第三行代码中，因为t是val的引用，所以val==t的结果一定是true

当我们传入右值，比如传入字面常量42：  
+ 类型T会实例化为int
+ 第一行代码会变成int t=val，t是一个值
+ 第二行代码t=fcn(t)，val的值不受影响
+ 第三行代码中，因为t在第二行代码中值可能被改变了，而val的值不变，所以val==t的结果不确定

我们可以看到传入左值和右值导致的结果可能大不相同，这是我们编写正确的代码变得困难。那怎么解决这个问题呢？  
首先我们通常将类型参数为右值引用的情况用于这两种场合：模板参数转发、模板重载。（我们将在后面做介绍）  
如果是在模板重载的情况，我们会多声明一个函数模板，避免左值进入类型参数为右值引用的模板，从而避免程序错误：  
```c++
template <typename T> void f(T&&);      //  绑定非const右值
template <typename T> void f(const T&); //  绑定左值和const右值
```

## 模板参数转发
刚刚提到模板参数类型是右值引用的情况，主要用于模板参数转发和模板重载。现在让我们来探讨模板参数转发。  
转发就是某些函数需要将一个或多个实参连同类型不变地转发给其他函数，比如在函数中调用其他函数。我们来举一个例子：  
```c++
template <typename F,typename T1,typename T2>
void flip1(F f,T1 t1,T2 t2){
    f(t2,t1);
} 
```

这个函数模板的功能很简单，传入一个可调用对象f，然后逆序调用参数t1和t2。这个函数一般情况下能很好地运行，但如果f的函数参数是引用时，它就会出现问题了：  
```c++
void f(int v1,int v2){
    cout << v1 << " " << ++v2 << endl;
}
```

这个函数f在调用的同时，参数v2会完成自增。就像这样：  
```c++
f(42,i);    //  i会加1
```

但是如果我们将函数f传递给函数模板flip1时，却不会自增了。  
```c++
flip1(f,j,42);  //  这里j不会变化
```

我们先来看实例化后的函数：  
```c++
void flip1(void(*fcn)(int,int &),int t1,int t2);
```

我们传进去的可调用对象f参数依然是引用，但是t1不是引用。j传递给t1的时候进行了拷贝，形成一份副本t1'，再将t1'传递给函数f。结果临时副本t1'完成了自增，但原来的变量t1并没有自增。  

<br>

所以这里我们应该传递引用。但问题来了，我们希望t1，t2被传递时保持被转发实参的所有性质，包括实参的类型、是否为const、实参是左值还是右值。  
如果我们改为（左值）引用，当我们给实参传递右值的时候就会报错。  
这时候我们想到之前讨论模板参数类型是右值引用时的表现：如果传入左值，函数参数会实例化为左值引用类型；传入右值，函数参数会被实例化为右值引用类型。而且无论传递是左值还是右值，都可以保持const属性，因为引用类型的const是底层的。所以我们将函数模板修改成下面这个样子：  
```c++
template <typename F,typename T1,typename T2>
void flip2(F f,T1&& t1,T2&& t2){
    f(t2,t1);
} 
```

这样当我们执行代码flip2(f,j,42)时，j会被转换成左值引用，再将引用传递给函数f，然后f递增了v2的同时，也改变了j的值。  

<br>

但是这段代码依然不是完美的，原因就在于可调用对象f不能接受右值引用参数的函数，例如：  
```c++
void g(int&& i,int& j){
    cout << i << " " << j << endl;
}
```

可能你会疑惑，我们传递给t2时，不是得到了右值引用类型了吗？为什么不能调用参数是右值引用类型的函数？  
别忘了我们上面讲到的，[右值的引用是一个左值！](#tip_1)  
为了解决这个问题，我们引入标准库中的参数转发函数forward。forward定义在头文件utility中，使用时必须显式定义参数类型。它的功能是返回该显式实参类型的右值引用，即forward\<T>的返回类型是T&&。  
我们使用forward重写代码：  
```c++
template <typename F,typename T1,typename T2>
void flip2(F f,T1&& t1,T2&& t2){
    f(std::forward<T2>(t2),std::forward<T1>(t1));
} 
```

forward\<Type>如果实参是右值，则Type是一个普通（非引用）类型，返回Type&&。如果实参是左值，则Type是一个左值引用类型，通过引用折叠返回一个左值引用类型Type&。

## std::move()原理
最后借着之前提到的引用折叠，这里就探讨一下std::move()函数的原理。  
std::move()函数可以将一个左值转换成右值引用。  
我们先给出move()函数的标准库代码：  
```c++
template<typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    return static_cast<typename remove_reference<T>::type &&>(t);
}
```

模板参数类型T是一个右值引用类型，就像之前讲的那样，它可以接受任何类型的参数。我们可以给它传递一个左值，也可以传递一个右值。  
接下来，我们来细究传递左值和传递右值时，move()函数是如何工作的。  

<br>

当我们传入右值，例如：  
```c++
std::move(string("bye"));
```

+ 编译器推断出T的类型是string
+ remove_reference\<string>的type是string
+ 参数t是string&&类型，所以static_cast\<string&&>(t)什么也不做
+ 返回值是string&&类型

所以，传入右值时，函数实例化为：  
```c++
string&& move(string &&t);
```

当我们传入左值，例如：  
```c++
string s1("hi");
std::move(s1);
```

+ 编译器推断出T的类型是string&
+ remove_reference\<string&>的type是string
+ 参数t是string& &&类，折叠为string&
+ static_cast\<string&&>(t)强制转化t为string&&类型
+ 返回值是string&&类型

所以，传入左值时，函数实例化为：  
```c++
string&& move(string &t);
```

这里注意，c++中不能隐式地将一个左值转换为右值引用，但是允许显式地用static_cast将一个左值转换为右值引用。参数t的类型是一个左值引用类型，左值引用也是一个左值，所以允许显式地转换为右值引用类型。  

> 对于操作右值引用的代码来说，将一个右值引用绑定到一个左值的特性允许它们截断左值。截断一个左值是安全的，一方面c++认可了这种转换，另一方面通过显式调用static_cast,c++试图阻止我们意外地进行这种转换。


最后，move()函数和forward()函数的区别是：move()会无条件的将一个参数转换成右值，而forward()则会保留参数的左、右值类型。

## 总结
> + 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值
> + 左值引用只能绑定非const左值；const左值引用可以绑定左值和右值；右值引用只能绑定右值
> + 如果一个函数参数是一个左值引用时，只能给它传递一个左值
> + 如果一个函数参数是常量左值引用时，我们可以给它传递任何实参（不论左值还是右值，const还是非const）
> + 如果一个函数参数是一个右值引用时，我们可以传递一个右值
> + 引用折叠只能应用于间接裁剪的引用的引用，比如类型别名或模板参数
> + 如果一个函数参数是一个右值引用（T&&）时，则可以传递任意类型的实参（不论左值还是右值，const还是非const）
> + 如果一个函数参数是一个右值引用（T&&）时，传入左值和右值可能会导致函数内的逻辑表现不同
> + 如果一个函数参数是一个右值引用（T&&）时，它对应的const属性和左值/右值属性将得到保持
> + 如果一个函数参数是一个右值引用（T&&）时，forward会保持实参类型的所有细节 
> + std::move()会无条件的将一个参数转换成右值，而std::forward()则会保留参数的左、右值类型

# Reference
[1] <<C++ Primer>>  
[2] [Value categories](https://en.cppreference.com/w/cpp/language/value_category)  
[3] [常量左值引用可以绑定右值的原因](https://blog.csdn.net/guniwi/article/details/105276432)  
[4] [C++ 左值和右值](https://blog.csdn.net/TABE_/article/details/122609775)  
[5] [std::move的理解和使用](https://blog.csdn.net/Huoon/article/details/113917219)  
[6] [std:move基本用法和理解](https://blog.csdn.net/zhoumoon/article/details/108276324)  