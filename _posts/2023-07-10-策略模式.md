---
title: 读书笔记 —— 策略模式
authors: fanventory
date: 2023-07-10 14:23:00 +0800
categories: [Reading Notes, Head First Design Patterns]
tags: [C++, Reading Notes]
---

# 策略模式
> 当我们的类中存在某个属性分为很多情况，且可能会新增新的属性值时，策略模式给我们提供了一个很好的设计思路。把这些变化的属性分离出来，抽象成接口，然后类根据这些接口进行组合，实现易扩展、易维护。

<br>
<br>

## 场景

我们运用面向对象思想，设计了一个鸭子基类，它实现三个方法：  

| Duck |
| -- |
| quack() (叫声) |
| swim() (游泳) |
| display() (行为) |

我们在鸭子基类的基础上，可以实现各种具体的鸭子实例，比如：  

| MallardDuck |
| -- |
| display(){ <br> // 看起来像绿头鸭 } |

| RedheadDuck |
| -- |
| display(){ <br> // 看起来像红头鸭 } |

现在我们需要对鸭子对象进行升级，比如令它拥有飞行技能，根据面向对象思想，我们给它的基类增加一个fly()方法即可：  

| Duck |
| -- |
| quack() (叫声) |
| swim() (游泳) |
| display() (行为) |
| fly() (飞行) |

改到这里，我们感觉没什么问题了。但是，产品上线的时候，发现橡皮鸭(继承了duck类)，在天上飞！这明显不符合现实逻辑。  

于是我们的解决办法是令橡皮鸭子的fly()方法改为空(什么也不做)，这样橡皮鸭子就不会飞了！

但是问题又来了，fly()方法是没问题了，但是我们添加了一个新的鸭子品种：木质鸭。它也继承了duck类，在程序上表现得又会飞又会叫。  

为了解决这个问题，我们把基类中的方法改为抽象类，然后在具体的鸭子类中实现具体行为。这样红头鸭会发出嘎嘎叫，还会飞；橡皮鸭会发出吱吱叫，但不会飞；木质鸭既不会叫也不会飞。 

但是问题还没有结束，如果鸭子的飞行行为只有会飞和不会飞两种还好，但如果鸭子的飞行行为有很多种，且可能会不断添加新的飞行行为。我们需要不断为所有类实现fly()方法。我们发现这样的设计，不但无法复用代码，而且难以维护！

我们参考以下3个设计原则来解决问题。

1. 隔离变化：识别应用中变化的方面，把它们和不变的方面分开。  

根据这个原则，我们把飞行行为和发声行为抽出来，封装成接口(或抽象类)；而鸭子本身不变(或极少变化)的属性(比如鸭子形状)继续留在基类中。抽取出来的接口就像下面这样：  

| FlyBehavior(接口) |
| -- |
| fly() |

| FlyWithWings(实现1) |
| -- |
| fly(){ <br> // 实现鸭子飞行 } |

| FlyNoWay(实现2) |
| -- |
| fly(){ <br> // 什么也不做——不会飞 } |

以及发声行为的接口

| QuackBehavior(接口) |
| -- |
| quack() |

| Quack(实现1) |
| -- |
| fly(){ <br> // 实现鸭子嘎嘎叫 } |

| Squack(实现2) |
| -- |
| fly(){ <br> // 实现鸭子吱吱叫 } |

| MuteQuack(实现3) |
| -- |
| fly(){ <br> // 什么也不做——不会叫 } |

然后我们在类中添加这两个接口的实例变量：  

| Duck |
| -- |
| FlyBehavior flyBehavior |
| QuackBehavior quackBehavior |
| |
| performQuack() (执行quackBehavior) |
| swim() (游泳) |
| display() (行为) |
| performFly() (执行flyBehavior) |

2. 编程到接口：针对接口编程，而不是针对实现编程

当我们需要添加新的飞行行为时，我们需要在接口添加新的实现，而不是在基类或子类中添加，这样子类可以引用新的接口实现，从而实现代码复用。

比如我们为fly()接口新增一个飞行行为：  

| FlyWithRocket(实现3) |
| -- |
| fly(){ <br> // 鸭子装上火箭推进器！ } |

3. 组合优于继承：优先使用组合而不是继承

现在我们有一系列飞行行为和发声行为的接口实现，但我们需要添加一种新的品种的鸭子，我们应该从这一系列接口实现进行组合，而不是通过继承重写fly()和quack()方法。新品种鸭子的组合行为就像下面这样：  

```c++
public class DecoyDuck: public Duck
{
public:
    DecoyDuck(){
        //  从一系列接口实现中，组合你需要实现的鸭子特性
        this->flyBehavior = new FlyBehavior();
        this->quackBehavior = new QuackBehavior();
    }
}
```

例如针对木质鸭，它既不会飞，也不会叫，我们为该类传入FlyNoWay接口和MuteQuack接口。  

而且这种实现为我们带来了额外的好处：我们可以在运行时动态改变接口实现。  

```c++
//  传入你想要修改的那个接口实现
void setFlyBehavior(FlyBehavior fb){
    this->flyBehavior = fb;
}

void setQuackBehavior(QuackBehavior qb){
    this->quackBehavior = qb;
}
```

但我们给木质鸭装上火箭推进器，它就能飞了。在运行时，我们像下面这样修改接口实现，完成这个功能，这种能力是继承所不具备的。

```c++
DecoyDuck dduck = new DecoyDuck();
dduck->performFly();     //  不会飞
dduck->setFlyBehavior(new FlyWithRocket()); //  装上火箭推进器
dduck->performFly();     //  会飞了
```

上面这个例子运用的就是策略模式！

## 定义

策略模式：  
定义一个算法族，分别封装起来，使得它们之间可以任意组合和变换。策略让算法的变化独立于使用它的用户。

![图片1](/posts/image/策略模式_pic1.png)

## 优缺点

+ 优点：  
扩展性好，可以在不修改基类结构的情况下，为新的算法进行添加新的实现  
灵活性好，可以对算法进行自由切换

+ 缺点：  
使用策略变多，增加系统复杂性  
客户端必须知道所有的策略类才能进行调用

## 总结

> + 识别应用中变化的方面，把它们和不变的方面分开
> + 针对接口编程，而不是针对实现编程
> + 优先使用组合而不是继承
> + 策略模式：定义一个算法族，分别封装起来，使得它们之间可以任意组合和变换。策略让算法的变化独立于使用它的用户

# Reference
[1] <\<Head First 设计模式>>  
[3] [Java进阶篇设计模式之十一 ---- 策略模式和模板方法模式](https://www.cnblogs.com/xuwujing/p/9954263.html)  