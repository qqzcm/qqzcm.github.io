---
title: 读书笔记 —— 网络编程_服务器IO模型简介
authors: fanventory
date: 2023-06-15 14:38:00 +0800
categories: [Reading Notes, Linux高性能服务器编程]
tags: [C++, IO模型]
---

# 服务器编程框架/IO模型
> 本节先介绍了一下服务器的编程框架，主要分为三个部分：IO处理单元、逻辑单元、网络存储单元。逻辑单元因服务器具体业务而异，网络存储单元不是必要的。而IO处理单元是网络编程中的重要部分。对应的IO模型一般有四种：阻塞IO、非阻塞IO + IO复用、非阻塞IO + SIGIO信号、异步IO。接下来我们将围绕这四种模型简单介绍。

<br>
<br>

## 服务器编程框架
介绍IO模型之前，我们先简单了解一下服务器的框架，IO是服务器框架中的一部分。  
服务器编程框架一般分为三个部分：IO处理单元、逻辑单元、网络存储单元。如下图所示：  

![图片1](image/服务器IO模型简介_pic1.png)

1. IO处理单元  

IO处理单元是服务器管理客户连接的模块。  
它的功能是：  
+ 等待并接收新的客户连接
+ 接收客户数据
+ 将服务器响应数据返回给客户端

对于一个服务器集群来说，IO处理单元是一个专门的接入服务器，它实现负载均衡，从所有逻辑服务器中选择负荷最小的一台来为新客户服务。  

> 这里注意，数据的收发不一定在IO处理单元中执行，也可能在逻辑单元中执行，取决于事件处理模式。

2. 逻辑单元 

逻辑单元一般是一个线程或进程。  
它的功能是：  
+ 分析并处理客户数据
+ 将结果传递给IO处理单元或直接发给客户端(取决于事件处理模式)

对于一个服务器集群来说，集群有多台逻辑服务器，每台服务器有多个逻辑单元，可以实现对多个用户任务的并行处理。

3. 网络存储单元

网络存储单元是数据库、缓存和文件，也可以是一台单独的服务器。  
它的功能是获取或存储客户交互过程中的各种数据。    

> 它不是必须的，比如ssh、telnet等登录服务不需要网络存储单元。

4. 请求队列

图中的请求队列其实就是各个单元之间的通信。  

IO处理单元接受客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样地，多个逻辑单元同时访问一个存储单元时，需要某种机制来协调处理竞争条件。  
在服务器集群中，各个单元是单独的服务器，它们通过TCP连接进行通信，而且这种TCP连接是永久的、预先建立的、静态的。这种TCP连接能提高服务器之间交换数据的效率，避免动态建立TCP连接导致的额外的系统开销。

<br>

最后我们通过一个表来总结服务器的基本模块。

| 模块 | 单个服务器 | 服务器集群 |
| -- | -- | -- |
| IO处理单元 | 处理客户连接，读写网络程序 | 作为接入服务器，实现负载均衡 |
| 逻辑单元 | 业务进程或线程 | 逻辑服务器 |
| 网络存储单元 | 本地数据库、文件、缓存 | 数据库服务器 |
| 请求队列 | 各单元之间的通信方式 | 各服务器之间永久的TCP连接 |

## IO模型

IO模型分为四种，其中非阻塞IO需要搭配其他IO通知机制一起使用：  

1. 阻塞IO

socket在创建时默认是阻塞的，当阻塞IO执行的系统调用因无法立即完成时，会被操作系统挂起，直到等待事件发生为止。  

+ 比如客户端通过connect向服务器发起连接，connect会先发送同步报文，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，connect调用就会被挂起。直到客户端接收到确认报文段，然后唤醒connect调用。  

在socket的基础API中，可能被阻塞的系统调用包括accpet、send、recv和connect。

2. 非阻塞IO

许多系统调用可以通过一些参数设置为非阻塞。

+ 比如我们可以给socket系统调用的第二个参数传递SOCK_NONBLOCK标志，或通过fcntl系统调用的F_SETFL命令，设置为非阻塞。

非阻塞IO执行的系统调用总是立即返回的。如果事件没有发生，这些系统调用会返回-1。为了区分这些系统调用是出错了，还是事件没有发生，errno会记录这些系统调用返回-1的原因。

+ 比如accept、send和recv调用，如果事件未发生，errno通常被设置为EAGAIN(再来一次)或EWOULDBLOCK(期望阻塞)。connec调用，如果事件未发生，errno则被设置为EINPROGRESS(在处理中)。

显然，我们需要在事件已经发生的情况下操作非阻塞IO，才能提供程序效率。所以非阻塞IO需要和其他IO通知机制一起使用，比如IO复用和SIGIO信号。

3. 非阻塞IO + IO复用

IO复用是最常用的IO通知机制。它是指应用程序通过IO复用函数向内核注册一组事件，内核通过IO复用函数将其中就绪的事件通知给应用程序。  

+ 比如Linux上常用的IO复用函数是select、poll和epoll_wait。

IO复用函数本身是阻塞的，它们能够提高程序效率的原因是：它们能够同时监听多个IO事件。

4. 非阻塞IO + SIGIO信号

SIGIO信号也是用来报告IO事件的。  
它的原理是如果为目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数就会触发，我们就可以在该信号处理函数中对目标文件描述符执行非阻塞IO操作。

5. 异步IO

上述介绍的阻塞IO、非阻塞IO + IO复用、非阻塞IO + SIGIO信号都是同步IO模型。它们都是在IO事件发生后，由应用程序来完成接下来的读写操作。   
POSIX规范的异步IO模型不同，用户事先告诉内核读写缓冲区的位置，以及IO操作完成后内核通知应用程序的方式。  
然后用户可以直接对IO执行读写操作。异步IO的读写操作总是立即返回的，无论IO是否阻塞，因为真正的读写操作由内核接管。  
Linux提供了异步IO的支持，对应的函数存储在aio.h的头文件中。


> 同步IO模型向应用程序通知的是IO就绪事件，而异步IO模型向应用程序通知的是IO完成事件。

最后我们通过一个表来总结这些IO模型。

| IO模型 | 读写操作及阻塞阶段 |
| -- | -- |
| 阻塞IO | 程序阻塞于读写函数 |
| 非阻塞IO + IO复用 | 程序阻塞于IO复用函数，但可同时监听多个IO事件，对IO本身的读写操作是非阻塞的 |
| 非阻塞IO + SIGIO信号 | 信号触发读写就绪事件，用户程序执行读写操作，用户程序没有阻塞阶段 |
| 异步IO | 内核执行读写操作并触发读写完成事件，用户程序没有阻塞阶段 |

## 总结
> + 服务器编程框架一般分为三个部分：IO处理单元、逻辑单元、网络存储单元
> + IO处理单元是服务器管理客户连接的模块
> + 逻辑单元一般是一个线程、进程或一台服务器
> + 网络存储单元是数据库、缓存和文件，也可以是一台单独的服务器
> + 在服务器集群中，各个单元是单独的服务器，它们通过永久的、预先建立的、静态的TCP连接进行通信
> + IO模型分为四种：阻塞IO、非阻塞IO + IO复用、非阻塞IO + SIGIO信号、异步IO
> + Linux提供了异步IO的支持，对应的函数存储在aio.h的头文件中
> + 同步IO模型向应用程序通知的是IO就绪事件，而异步IO模型向应用程序通知的是IO完成事件

# Reference
[1] 《深入解析高性能服务器编程》    