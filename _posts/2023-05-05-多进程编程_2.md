---
title: 读书笔记 —— 多进程编程_2
authors: fanventory
date: 2023-05-05 16:39:00 +0800
categories: [Reading Notes, Linux高性能服务器编程]
tags: [C++, Multiprocess]
---

# wait/waitpid/pipe
> 本节探讨了父、子进程中的状态问题，有两种情况子进程会进入僵尸态：1.子进程结束，父进程读取其退出状态前；2.父进程结束或异常，子进程被init进程接管时也会处于僵尸态。操作系统提供了wait和waitpid两个系统调用来立即结束子进程的僵尸状态。然后，文章介绍了父、子进程之间可以通过管道pipe来进行通信。

<br>
<br>

## wait/waitpid
在多进程程序中，父进程往往需要追踪子进程的退出状态。因此，当子进程结束时，内核不会立即释放子进程的进程表表项，以满足父进程后续对子进程退出信息的查询。  
所以在子进程退出后，父进程读取其退出状态前，子进程会处于`僵尸态`。  
还有一种情况会造成子进程僵尸态：如果父进程结束或异常终止，而子进程继续运行，此时子进程的PPID会被操作系统设置为1，即pid为1的进程是init进程。init进程接管了子进程，并等待它结束。所以父进程退出后，子进程退出前，子进程也会处于僵尸态。

如果父进程没有正确处理子进程的返回信息，子进程会处于僵尸态，占据内核资源。这时我们需要在父进程中调用wait/waitpid函数，等待子进程结束，并获取子进程的返回信息，从而使子进程立即从僵尸态中结束。

下面是wait/waitpid的系统调用，功能是等待子进程结束，并获取子进程的返回信息，使子进程立即从僵尸态中结束，其函数原型如下：  

```c++
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *stat_loc);
pid_t waitpid(pid_t pid, int *stat_loc, int options);
```

参数和返回值：  
+ stat_loc：存储子进程退出状态信息
+ pid：指定等待的子进程，如果pid取-1，则等待任意一个子进程结束
+ optios：控制waitpid函数的行为。一般取WNOHANG，表示waitpid调用是非阻塞的，如果pid指定的目标子进程未结束或意外终止，返回0；如过目标子进程正常退出，返回子进程的PID
+ 返回值：返回结束运行的子进程PID，如果调用失败返回-1，并设置errno

wait函数是等待任意子进程结束，而waitpid函数是等待特定的子进程结束。  
在sys/wait.h头文件中，定义了一些用来帮助结束子进程退出状态信息的宏。如下表所示：  

| 宏 | 含义 |
| -- | -- |
| WIFEXITED(stat_val) | 如果子进程正常结束，返回一个非0值 |
| WEXITSTATUS(stat_val) | 如果WIFEXITED非0，返回子进程的退出码 |
| WIFSIGNALED(stat_val) | 如果子进程是因为一个未捕获信号而终止，返回一个非0值 |
| WTERMSIG(stat_val) | 如果WIFSIGNALED非0，返回信号值 |
| WIFSTOPPED(stat_val) | 如果子进程意外终止，返回一个非0值 |
| WSTOPSIG(stat_val) | 如果WIFSTOPPED非0，返回信号值 |

例子如下：  
```c++
static void handle_child(int sig){
	pid_t pid;
	int stat;
	while((pid = waitpid(-1, &stat, WNOHAND)) > 0){
		//	对结束的子进程进行善后处理
	}
}
```

## 管道
父/子进程之间可以通过管道pipe来传递数据

下面是pipe的系统调用，功能是创建一条管道，通过一对文件描述符对管道进行读写，其函数原型如下：
```c++
#include <unistd.h>
int pipe(int fd[2]);
```

参数和返回值：
+ fd[2]：包含两个int型整数的数组指针，存储创建的文件描述符
+ 返回值：成功返回0，失败返回-1，并设置errno

pipe函数构建的两个文件描述符fd[0]和fd[1]构成管道的两端，其中fd[1]用于往管道写入数据，fd[0]用于往管道读取数据，并且它们不能反过来使用。所以一对文件描述符只能保证父、子进程间一个方向的数据传输。父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]。就像下面这样：  

```
关闭fd[0]           关闭fd[1]
父进程 --> 管道 --> 子进程  
写入	            读取
```

如果要实现父、子进程之间的双向数据传输，就必须使用两个管道。  

> 管道提供的这一对文件描述符默认是阻塞的，即我们用read系统调用读取一个空管道时会发生阻塞，直到管道内有数据可读；我们用write系统调用往一个满的管道写入时，也会发生阻塞，直到管道有足够多的空闲空间为止。当然，管道也可以设置为非阻塞的，此时read和write的行为会有不同的行为。

socket编程接口提供了一个创建全双工管道的系统调用socketpair。  
下面是socketpair的系统调用，功能是创建一条双向管道，这条管道对应的一对文件描述符即可读也可写，其函数原型如下：
```c++
#include <sys/types.h>
#include <sys/socket.h>
int socketpair(int domain, int type, int protocol, int fd[2]);
```

参数和返回值：  
+ domain：指定协议，只能指定UNIX本地域协议族AF_UNIX
+ type：指定服务类型，取值有：流服务SOCK_STREAM，数据报服务SOCK_UGRAM
+ protocol：在前两个参数构成的协议集合中，再选择一个具体的协议，默认0
+ fd[2]：包含两个int型整数的数组指针，存储创建的文件描述符
+ 返回值：成功返回0，失败返回-1，并设置errno

不过，管道只能用于有关联的两个进程，比如父子进程，子进程会继承父进程打开的文件描述符，从而实现管道通信。

> 管道的容量是有限制的。自Linux 2.6.11内核起，管道容量大小默认是65536字节。可以通过fcntl函数修改管道容量。

当父、子进程关闭管道时，对应的引用计数为减1，只有引用计数减至0时才会真正地关闭文件描述符。  
如果管道写端的文件描述符fd[1]的引用计数为0，则对fd[0]调用read函数时会返回0，即读取文件结束标记(EOF)。反之，如果管道读端的文件描述符fd[0]的引用计数为0，则对fd[1]调用write函数则会失败，引发SIGPIPE信号。

## 总结
> + 操作系统提供了wait/waitpid的系统调用，功能是等待子进程结束，并获取子进程的返回信息，使子进程立即从僵尸态中结束
> + 操作系统提供了pipe的系统调用，功能是创建一条管道，通过一对文件描述符对管道进行读写
> + socket网络编程接口提供了socketpair的系统调用，可以创建一条全双工管道

# Reference
[1] 《深入解析高性能服务器编程》    