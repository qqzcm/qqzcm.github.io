---
title: 刷题笔记 —— 使数组按非递减顺序排列
authors: fanventory
date: 2023-04-25 14:57:00 +0800
categories: [leetcode]
tags: [leetcode, LinkList, Monotonic Stack]
---

# 链表/单调栈
> 该问题是迭代地使数组成为非递减顺序，由于时间限制，不能用N次迭代的方式解决。该问题的解法分为两种，一种是通过链表模拟，多点向后推进。另一种方法是用单调栈记录前一个最大元素的状态

<br>
<br>

## 题目
给你一个下标从 0 开始的整数数组 nums 。在一步操作中，移除所有满足 nums[i - 1] > nums[i] 的 nums[i] ，其中 0 < i < nums.length 。

重复执行步骤，直到 nums 变为 非递减 数组，返回所需执行的操作数。


## 例子

#### 示例1
```
输入：nums = [5,3,4,4,7,3,6,11,8,5,11]
输出：3
解释：执行下述几个步骤：
- 步骤 1 ：[5,3,4,4,7,3,6,11,8,5,11] 变为 [5,4,4,7,6,11,11]
- 步骤 2 ：[5,4,4,7,6,11,11] 变为 [5,4,7,11,11]
- 步骤 3 ：[5,4,7,11,11] 变为 [5,7,11,11]
[5,7,11,11] 是一个非递减数组，因此，返回3。
```

#### 示例2
```
输入：nums = [4,5,7,7,13]
输出：0
解释：nums 已经是一个非递减数组，因此，返回0。
```

## 条件
+ 1 <= nums.length <= 10^5
+ 1 <= nums[i] <= 10^9

## 难点分析
该题难点在于：(1)数组通过N次迭代获得结果，如果我们也通过N次迭代模拟程序行为，则会超时，这就要求我们需要在O(n)时间内计算出结果；(2)例如[4,14,13,2,6,13],14会吞噬13，而13会吞噬2，如果从左往右一次判断，可能错误认为14通过两次吞噬消除13和2；(3)例如
[10,1,2,3,4,5,6,1,2,3]，10吞噬6次，而最后三个元素是6吞噬的，这要求我们记录每个元素吞噬次数的结果。但由于迭代过程数组下标会发生变化，吞噬次数的中间结果记录比较困难。  
该问题提出两种解法，首先介绍最优的单调栈解法。  
我们以示例一[5,3,4,4,7,3,6,11,8,5,11]为例，红色部分对应最后的结果，即最后得到的非递减数组[5,7,11,11]。

![图片1](image/使数组按非递减顺序排列_pic1.png)

我们可以发现以下规律：  
+ 每一次迭代对应元素就会被删除，也就是说迭代的次数等价于元素被删除的最大次数
+ 一个元素如果被吞噬，则最终会被左边最大的元素吞噬
+ 如果当前元素大于左边所有元素，那右边的所有元素都不会被左边的元素吞噬，也就是说左边的删除次数不需要再计算

受到启发，单调栈存储左边的元素，而且保证左边元素是当前遇到最大的(5)。当我们遇到第二个红色的元素(7)时。由于右边元素不会被左边的元素吞噬，也就是元素7之前的吞噬次数我们是可以确定的。所以出栈进行计算。然后把当前最大的元素(7)入栈。如果接下来的元素都比它小，吞噬次数不断加1。  
以此类推，直到遍历完整个数组。  
我们可以看到，[5,3,4,4,7,3,6,11,8,5,11]中，遍历元素3,4,4时，只要栈中还有元素，说明前面有更大的元素(5)，这些元素都会被吞噬，所以依次出栈，且吞噬次数等于上一个元素的吞噬次数加1。  

<br>

第二种解法是链表模拟。
第一步我们先找出可以吞噬的候选元素，如下图所示：  

![图片2](image/使数组按非递减顺序排列_pic2.png)

我们用数组next来代替链表中的next指针。每个候选元素都模拟吞噬行为向右移动一步，如下图所示：  

![图片3](image/使数组按非递减顺序排列_pic3.png)

对于每个候选元素而言：  
+ 要么它吞噬掉后续元素，那么我们将当前元素的next指向下个元素
+ 要么它被其他元素吞噬，我们用一个数组rem标识是否被吞噬

吞噬掉后续元素的集合进行下轮吞噬，直到没有发生任何吞噬行为，说明此时已经是非递减数组。最后我们进行了多少轮吞噬，即为结果迭代次数。  
原始的迭代方案会从头到尾判断是否能进行吞噬，非递减元素会遍历N次。相比之下，该解法每一个元素只经历了一次吞噬（删除），不会重复判断非递减元素。

## 解法

#### 解法1：单调栈
```c++
class Solution {
public:
    int totalSteps(vector<int>& nums) {
        int res = 0, f[nums.size()];
        stack<int> st;
        for(int i = 0; i < nums.size(); ++i) {
            int cur = 0;
            //  如果遇到比栈中元素更大的元素，说明需要进行清算(出栈)
            while(st.size() && nums[st.top()] <= nums[i]) {
                cur = max(cur, f[st.top()]);
                st.pop();
            }
            //  如果栈中有值，说明左边有更大的元素可以吞噬当前元素，所以吞噬次数+1
            if(st.size()) {
                res = max(res, cur + 1);
                f[i] = cur + 1;
            }
            st.push(i);
        }
        return res;
    }
};
```

#### 解法2：链表模拟
```c++
class Solution {
public:
    int totalSteps(vector<int>& nums) {
        nums.push_back(1e9 + 8);    //  方便处理边界
        vector<int> next;
        vector<int> cur;
        vector<int> rem;

        //  next数组记录当前元素nums[i]指向的下一个元素，模拟链表行为
        //  rem数组表示当前元素nums[i]是否被吞噬
        for(int i = 0 ; i < nums.size() ; i++){
            next.emplace_back(i + 1);
            rem.emplace_back(1);
        }
        
        //  先筛选一次候选元素，缩小搜索范围
        for(int i = nums.size() - 2 ; i >= 0 ; i--){
            if(nums[i] > nums[i + 1]){
                cur.emplace_back(i);
            }
        }
        
        for(int res = 0;; ++res){
            vector<int> tmp;
            for(auto &i : cur){
                //  如果候选元素可用且可以吞噬下一个元素，则更新信息并加入下一轮吞噬
                if(rem[i] && nums[i] > nums[next[i]]){
                    //  next[i]已经被吞噬了，设置为不可用状态
                    rem[next[i]] = 0;
                    //  模拟链表将next指针指向下一个元素
                    next[i] = next[next[i]];
                    //  加入下一轮吞噬
                    tmp.emplace_back(i);
                }
            }
            //  如果这一轮候选元素没有吞噬任何值，则返回结果
            if(tmp.size()){
                tmp.swap(cur);
            }else{
                return res;
            }
        }
        return -1;
    }

};
```




## Reference
[1] [使数组按非递减顺序排列](https://leetcode.cn/problems/steps-to-make-array-non-decreasing)   
[2] [最优解：单调栈 | 次优解：单链表模拟 + 优化](https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solution/by-newhar-6k75/)