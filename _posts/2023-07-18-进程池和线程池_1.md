---
title: 读书笔记 —— 进程池和线程池_1
authors: fanventory
date: 2023-07-18 19:16:00 +0800
categories: [Reading Notes, Linux高性能服务器编程]
tags: [C++, Pthread Poll, Process Pool]
---

#  进程池概述
> 本节探讨了进程池(线程池)的一些概念，已经它们解决了什么问题。由于进程池和线程池在模型上类似，所以我们只讨论进程池。进程池是为了解决动态创建进程耗费时间、占用不必要的内核资源，且创建的子进程只能为一个客户服务等问题。所以我们预先在服务器创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性。进程池处理多客户任务时，需要注意两个问题：1.监听socket和连接socket是否都由主进程统一管理？这个问题涉及到服务器并发模型的确立。2.一个客户连接的所有任务是否始终由一个子进程来处理？这个问题涉及到服务器的是有状态的还是无状态的。

<br>
<br>

## 进程池(线程池)概述

动态创建子进程(子线程)的缺点：  
+ 耗费时间，导致客户响应慢
+ 创建的子进程(子线程)只能为一个客户服务，如果客户较多，过多的进程(线程)切换会耗费大量CPU时间
+ 动态创建的子进程是当前进程的完整映像，必须谨慎管理分配的文件描述符、堆内存等系统资源，否则会导致系统可用资源下降，影响服务器性能

为了解决动态创建进程(线程)的问题，我们提出了进程池(线程池)的概念：  
进程池是由服务器预先创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性(比如优先级、PGID等)。由于进程池在服务器启动初始化时就创建，所以每个子进程没有打开不必要的文件描述符和堆内存(从父进程继承或复制而来)。当新的任务到来时，主进程以某种方式选择进程池中的一个子进程来执行任务，这比动态创建子进程的代价小很多。  
主进程选择线程池中子进程的方式，主要有以下两种：  
1. 主进程通过某种算法来主动选择子进程(比如随机算法、Round Robin轮流选取算法)。
2. 主进程和所有子进程通过一个共享的工作队列来同步，所有子进程睡眠在该工作队列上。当新的任务到来时，主进程将任务添加到工作队列中，这将唤醒等待任务的子进程，该子进程执行新任务，而其他子进程继续睡眠(通过条件变量实现)。

当选择好子进程后，还需要通过某种通信机制来通知目标子进程，同时传递必要的数据。可以通过管道或其他全局共享数据结构实现。  
线程池的一般模型如下图所示：  

![图片1](image/进程池和线程池_pic1.png)

## 处理多客户

用进程池处理多个客户的连接时，可能会存在以下两个问题：  
1. 问题1：使用进程池处理多客户任务时，监听socket和连接socket是否都由主进程统一管理？  

不同的并发模式，管理这两种socket的方式不同：  
+ 半同步/半反应堆模式: 主进程统一管理这两种socket。
+ 半同步/半异步模式: 主进程管理所有监听socket，子进程分别管理属于自己的连接socket。
+ 领导者/追随者模式: 主进程管理所有监听socket，子进程分别管理属于自己的连接socket。

第一种情况中，主进程管理所有监听socket，然后传递给子进程。后两种情况中，子进程自身调用accept调用来接受新的连接，这样父进程不需要向子进程传递socket，只需要发送一个通知：新的连接事件到达。

2. 问题2：一个客户连接的所有任务是否始终由一个子进程来处理？  

这个问题同样分情况讨论：  
+ 如果客户任务是无状态的，我们可以使用不同的子进程处理同一客户的不同请求。
+ 如果客户任务是存在上下文关系的，我们应该一直用同一个子进程来服务，否则我们需要在各个子进程之间传递上下文(可以通过epoll的EPOLLONESHOT来确保同一个客户的连接被同一个进程处理)。

![图片2](image/进程池和线程池_pic2.png)

## 总结
> + 进程池是由服务器预先创建的一组子进程，这些子进程都运行相同的代码，并具有相同的属性

# Reference
[1] 《深入解析高性能服务器编程》    