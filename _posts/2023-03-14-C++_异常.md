---
title: 读书笔记 —— C++ 异常处理
authors: fanventory
date: 2023-03-14 14:25:00 +0800
categories: [Reading Notes,C++ Primer]
tags: [C++, Reading Notes,Expection]
---

# 异常处理
> `异常处理(expection handing)`机制是程序中独立开发的一个部分，它能够对运行时出现的问题进行通信并做出相应的处理。异常使我们能够将问题的检测和解决过程分离开来。程序的一部分负责检测问题的出现，当问题出现后将该错误信息传递给程序的另一部分，由程序的另一部分解决该问题。这样，检测环节无需知道问题处理模块的所有细节，反之亦然。本章中我们介绍了异常的抛出和捕获过程。捕获过程以栈展开的形式进行，匹配过程中类型转换还会受到限制，且栈展开过程中局部对象会被销毁。我们要注意析构函数不要抛出自身不能处理的异常，在文中我们将对其做出解释。接着我们介绍了异常对象即异常类的体系结构。C++中我们能通过(...)语法捕获所有异常，捕获所有异常通常与重新抛出一起使用。对于构造函数初始化列表中的异常，我们可以通过函数try语句块来捕获。最后我们介绍了异常说明符、异常运算符，以及函数指针和虚函数中异常说明需要保持一致的问题。

<br>
<br>

## 异常抛出
在C++中，我们可以通过`抛出(throwing)`一条表达式来`引发(raised)`一个异常。就像下面这样：  
```c++
//  抛出一个字符串
throw "error";
//  抛出一个对象
std::bad_alloc t;
throw t;
```

根据抛出的对象和内容，程序的抛出部分会告知程序的异常处理部分发生了什么错误。  
这里需要我们注意，当我们执行一个throw后，throw后面的语句不会再执行。程序的控制权会由throw转移到与之匹配的catch模块上。就像下面这样：  
```c++
try
{
    ...     //  异常发生后，前面创建的对象会被销毁
    std::bad_alloc t;
    throw t;
    ...     //  后面的代码不会执行
}
catch(std::bad_alloc &e)
{
    //  throw语句执行后，控制权来到catch模块
    cerr <<e.what()<<endl;
}
...    //   执行完catch模块后，程序从这里继续执行
```

这里有两个重要信息：  
1. 调用链的函数可能会提早退出
2. 一旦程序开始处理异常代码，则沿着调用链创建的局部对象会被销毁

## 栈展开
刚刚我们提到，程序throw之后，会进入catch模块，那如果有多个catch模块呢？它会进入哪一个？
首先进入哪一个catch模块是由抛出表达式（或对象）的类型和当前调用链共同决定的，感觉抛出表达式（或对象）的类型，会选中调用链中与该类型匹配的最近的catch模块。  
接下来我们看一下详细的流程：  
+ 当抛出一个异常后，程序暂停当前函数的执行过程，并寻找与该异常匹配的catch子句
+ 当throw出现在一个try语句块内，检测与该try块关联的catch子句
+ 如果找到匹配的catch，就用该catch模块处理异常
+ 如果没找到匹配的catch，且该try语句嵌套在其他try块中，则检测外层try块匹配的catch子句
+ 如果还是找不到匹配的catch，则退出当前函数，在外层函数中检测try块匹配的catch子句
+ 如果依然找不到匹配的catch，继续退出当前函数，在更外层函数中检测try块匹配的catch子句
+ 依此类推，直到找到匹配的catch或者退出主函数

这个寻找匹配的catch的过程叫做`栈展开(stack unwinding)`。如果我们找到匹配的catch，执行完对应的catch模块后，会从try关联的最后一个catch子句之后的代码继续执行。而如果我们一直没找到匹配的catch，程序就会调用标准库函数`terminate`，终止当前程序。

## 栈展开过程中对象会自动销毁
在栈展开的过程中如果退出了某个块，编译器将这个块创建的对象正确地销毁。  
+ 如果异常发生在构造函数中，则当前的对象可能只构造了一部分，即有的成员已经初始化了，而有的成员没有初始化。这种情况下，我们要确保已经构造的成员被正确地销毁。
+ 如果异常发生在数组或者标准库容器的元素初始化过程中，可能异常发生之前已经构造了一部分元素，这时候我们要确保已经构造的元素被正确地销毁。

## 析构函数和异常
析构函数负责释放资源，但存在这么一种情况，释放资源之前发生了异常，然后剩余的释放资源的部分将不会被执行。就像下面这样：  
```c++
~ClassName::ClassName(){ //  析构函数
    doSomething();  //  发生了异常
    delete data;    //  释放资源
                    //  由于上面发生了异常，delete语句不会执行
}
```

为了解决这个问题，我们可以用智能指针（比如shared_ptr）来控制资源的释放，无论析构函数中是否发生了异常，当程序运行到作用域的末尾时，shared_ptr指针会检查计数器，从而正确地释放该资源（unique_ptr也可以做到）。

<br>

最后，析构函数不应该抛出不能被它自身处理的异常。也就是说，如果析构函数可能发生某个异常，应该将该操作放置在try块中，并在析构函数内部处理。就像下面这样：  
```c++
~ClassName::ClassName()
{
    try
    {
        do_something();
    }
    catch()
    {  
        //这里可以什么都不做，只是保证catch块的程序抛出的异常不会被扔出析构函数之外
    }
}
```


析构函数不能抛出异常的原因有以下两点：
1. 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
2. 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。  

## 异常对象
`异常对象(expection object)`是一种特殊的对象，编译器使用异常抛出的表达式来对异常对象进行拷贝初始化。

> 这里注意，throw语句中的表达式必须拥有完全类型，即必须实现定义。如果表达式是类类型的话，必须实现一个可访问的析构函数和拷贝或移动构造函数。如果表达式是数组或者函数类型，则表达式将被转换成与之对应的指针类型。

异常对象位于编译器管理的空间中，编译器确保无论调用哪个catch子块都能访问该空间。当异常处理完毕后，异常对象会被销毁。就像下面这样：  
```c++
try{
    throw Exception3(); //  这不是一个局部对象，并不会随着当前作用域结束而销毁
}catch(Exception1 ex){  
    ex.what();  //  输出错误信息
}catch(Exception2 ex){
    ex.what();
}catch(Exception3 ex){  //  异常对象可以在3个catch子块中被访问
    ex.what();
    //  异常处理完毕后，异常对象才被销毁
}
```

> 这里需要我们注意，因为退出某个块时，这个块内的局部对象也会被销毁，所以我们不能抛出一个指向局部对象的指针。 


## 捕获异常
`catch子句(catch clause)`中的`异常声明(exception declaration)`看起来像是只包含一个形参的函数形参列表。和函数形参一样，形参名可以省略，就像下面这样：  
```c++
catch (Exception) {  //  省略形参名
    doSomething();
}
```

声明的类型决定了代码能捕获什么样的异常。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。   
当我们进入一个catch语句后，通过异常对象初始化异常声明中的参数。如果catch是一个非引用类型，则该参数是异常对象的一个副本；如果参数是引用类型，则该参数是异常对象的一个别名，此时修改参数也会改变异常对象。  
catch的参数还有一个特性和函数类似：如果catch的参数是基类类型，可以用派生类类型初始化。此时，如果catch参数是非引用类型，则异常对象的副本会被切掉一部分。如果catch参数是引用类型，则该参数会以常规方式绑定到异常对象上。也就是说，如果参数是基类，则catch中无法使用派生类特有的成员。就像下面这样：  
```c++
//  定义一个基类的异常类
class BaseException: public exception {
public:
	void what() {
		cout << "BaseException what()" << endl;
	}
};
//  定义一个派生类的异常类
class DerivedException: public BaseException {
public:
	void what() {
		cout << "DerivedException what()" << endl;
	}
};
//  主函数
int main() {
	try {
        throw DerivedException();   //  抛出派生类
	}
	catch (BaseException ex) {  //  非引用类型，会被切掉一部分
		ex.what();  //  输出BaseException what()
	}
    catch (BaseException& ex) {  //  引用类型，但不能使用派生类特有的方法
		ex.what();  //  输出BaseException what()
	}
	return 0;
}
```

## 查找匹配的处理代码
在寻找catch的匹配时，我们最终找到的不一定是最佳匹配，而是第一个与异常匹配的catch语句。所以，越是专门的catch越应该置于整个catch列表的前端。同理，派生类的异常处理代码应该放在基类的处理代码之前。

<br>

除此之外，catch语句中形参与实参的匹配规则会有许多限制，绝大多数转换是不被允许的，我们总结为以下四点：  
+ 允许从非常量类型转换为常量类型
+ 允许从派生类转换为基类
+ 允许数组转换为数组指针，函数转换为函数指针
+ 其他所有的转换规则都不被允许

## 重新抛出
有时候，一个单独的catch语句不能完整地处理整个异常，在执行某些校正操作之后，需要由更上一层函数接着处理异常。这时候我们可以通过`重新抛出(rethrowing)`的操作将异常传递给另一个catch语句。重新抛出的语法如下：  
```c++
catch (Exception ex) {
    doSomething();
    throw;
}
//  注意不能写出这样
catch (Exception ex) {
    doSomething();
    throw ex;   //  错误，这样会抛出一个副本，而不是原来的异常
}
```

空的throw语句只能出现在catch语句或者catch语句直接或间接调用的函数之内。如果在catch模块之外使用了空throw语句，则编译器会调用terminate。   
很多时候，catch语句会改变参数的内容，如果我们希望改变之后的内容重新抛出，则catch的异常声明应该是引用类型。就像下面这样：  
```c++
catch (BaseException ex) {  //  非引用类型
    set_status(ex);         //  改变状态
    throw;                  //  只修改了异常对象的局部副本
}
catch (BaseException& ex) { //  引用类型
    set_status(ex);         //  改变状态
    throw;                  //  修改了异常对象
}
```

## 捕获所有异常的处理代码
我们可以用省略号作为异常声明，这样程序会`捕获所有异常(catch-all)`。就像下面这样：  
```c++
catch (...) {   //  捕获任意类型的异常
    doSomething();
    throw;      //  修改了异常对象
}
```

catch(...)通常和重新抛出语句一起使用，catch子句中执行当前局部能完成的工作后，重新抛出异常。  
catch(...)既能单独出现，也可以与其他catch语句一同出现。如果catch(...)与其他几个catch语句一同出现时，catch(...)必须在最后的位置，因为出现在catch(...)后面的语句永远不会被匹配。

## 函数try语句块和构造函数
构造函数是这样实现的：  
```c++
Blob::Blob(std::initializer_list<string>):data(std::make_shared<vector<string>>(il))
{
    try{
        doSomething();  //  其他初始化操作
    }catch(Exception e){
        e.what();
    }
}
```

如果我们需要在构造函数内加try-catch块，会有一个问题。那就是成员变量data在进入函数体之前先执行初始化列表，如果初始化列表的过程发生异常，try中的语句块还未生效，所有函数体内的catch语句也无法处理初始化列表中抛出的异常。  
想要处理构造函数初始值抛出的异常，我们需要将构造函数写出`函数try语句块(function try block)`。语法如下：  
```c++
Blob::Blob(int a, double b, string c) try: data(std::make_shared<vector<string>>(il))
{
    doSomething();  //  其他初始化操作
} catch(const std::bad_alloc &e){
    handle_out_of_memory(e);
}
```

这个catch既能处理构造函数体内抛出的异常，也能处理成员初始化列表抛出的异常。  

> 这里有一点要注意，参数中也可能发生异常，但是参数的异常不属于函数try语句块的一部分。参数初始化过程发生的异常，属于调用表达式的一部分，在调用者所在的上下文进行处理。

## noexcept异常声明
在c++新标准中，我们可以通过提供`noexcept说明(noexcept )`指定某个函数不会抛出异常，这样做的好处是会给编译器更大的优化空间。语法如下：
```c++
void recoup(int) noexcept;  //  不会抛出异常
void alloc(int);            //  可能抛出异常
```

对于一个函数来说，noexcept说明要么出现在该函数的所有声明和定义中，要么都不出现。  
+ 该说明应该在函数的尾置返回类型之前
+ 我们可以在函数指针的声明和定义中指定noexcept
+ 在typedef和类型别名中不能出现noexcept
+ 在成员函数中，noexcept说明符需要跟在const及引用符之后，在final、override或虚函数的=0之前

## 违反异常说明
哪怕我们对一个函数声明了noexcept，指出该函数不会抛出异常，但编译器并不会在编译时做检查（毕竟有一些运行时错误是检查不出来的）。  
所以一个函数如果声明了noexcept，并且在函数体内存在throw语句，或者在函数运行时调用了可能抛出异常的其他函数，这个函数也是可以通过编译的。就像下面这样：  
```c++
void f() noexcept
{
    throw exception();  //  违反了异常说明，但可以通过编译
}
```

但是这样编写代码的结果是：一旦一个noexcept函数抛出了异常，程序就会调用teminate确保遵守不在运行时抛出异常的承诺。  
在早期的C++设计中，异常说明是可以指定可能抛出的异常类型的。就像下面这样：  
```c++
void f() throw(length_error)    //  指出可能抛出的异常，这个写法已淘汰
{
    throw length_error();  
}
```

这个写法已淘汰，但是它还有一个重要的保留，如果函数后跟着throw()，就意味着该函数不会抛出异常。就像下面这样：  
```c++
void recoup(int) throw();
void recoup(int) noexcept;  //  这两条是等价的
```

## 异常说明的实参
异常说明符是可以带参数的，该参数必须能转换为bool类型，如果实参为true，则该函数不会抛出异常；如果实参为false，则该函数可能抛出异常。就像下面这样：  
```c++
void recoup(int) noexcept(true);    //  声明不会抛出异常
void recoup(int) noexcept(false);   //  声明可能抛出异常
```

## noexcept运算符
这里的noexcept运算符和上面介绍的noexcept说明符不同。noexcept运算符是一个一元运算符，它的功能是表示给定的表达式是否会抛出异常，返回bool类型的右值常量。就像下面这样：   
```c++
noexcept(recoup(i));    //  如果recoup(i)不会抛出异常则返回true，否则返回false
```

noexcept(e)当e调用的所有函数都做了不抛出异常说明，且e本身不含有throw语句时，结果才返回true；否则noexcept(e)返回false。  
noexcept运算符常常与noexcept说明符混合使用，就像下面这样：  
```c++
void f() noexcept(noexcept(g()));   //  f和g的异常说明一致
```

如果g承诺了不会抛出异常，则f也不会抛出异常；如果g没有承诺不会抛出异常，则f也可能抛出异常。

## 异常说明与指针、虚函数和拷贝控制
如果我们声明了一个函数指针是noexcept的，那它只能指向同样声明了noexcep的函数。相反，如果我们显式或隐式说明了一个函数指针可能抛出异常，它可以指向任何函数，即使是承诺了不抛出异常的函数。就像下面这样：  
```c++
void (*pf1)(int) noexcept = recoup; //  ok，pf1和recoup都声明了noexcept
void (*pf2)(int) = recoup;          //  ok，pf2未作noexcept声明，但recoup声明了noexcept
pf1 = alloc;    //  no，pf1声明了noexcept，不能指向可能抛出异常的函数
pf2 = alloc;    //  ok，pf2和alloc都可能抛出异常
```

如果一个虚函数承诺了不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺。相反，如果基类的虚函数允许抛出异常，则派生出来的虚函数既可以允许抛出异常，也可以不允许抛出异常。就像下面这样：  
```c++
//  基类
class Base{
public:
    virtual double f1(double) noexcept; //  不会抛出异常
    virtual int f2() noexcept(false);   //  可能抛出异常
    virtual void f3();                  //  可能抛出异常
};
//  派生类
class Derived: public Base{
public:
    double f1(double);          //  错误，Base::f1承诺不会抛出异常
    int f2() noexcept(false);   //  正确，与Base::f2的异常说明一致
    void f3() noexcept;         //  正确，Derived::f3做了更严格的规定
};
```

最后，新版本的编译器默认会给拷贝控制成员(拷贝/移动/析构函数)加上noexcept声明。  
而某些旧版的编译器会采用以下策略：  
+ 如果所有成员和基类都做了noexcept声明，则默认生成的拷贝控制成员也是noexcept的。相反，如果任何一个成员或基类可能抛出异常，则默认生成的拷贝控制成员是noexcept(false)的。
+ 如果定义了析构函数但没有提供异常说明，编译器会按照上述规则自动加上异常说明

## 异常类层次
标准库异常类的继承体系如图所示（图摘自《C++ Primer》）:  

![标准库异常类的继承体系](image/异常处理_pic1.jpg)

其中exception类是所有异常类的基础，它只定义了默认构造函数、拷贝构造函数、拷贝赋值运算符、虚析构函数、what()虚成员函数。其中what()成员返回一个const char*指针，指向一个null结尾的字符数组，用来输出错误信息，且确保不会抛出任何异常。同时，因为what()是虚函数，所以我们用基类捕获异常时，调用的what函数是与异常对象动态类型对应的版本。  
当我们自定义异常类的时候，需要基础exception类，并重写它的成员方法：  
```c++
class MyException :public exception{    //  继承exception类
public:
    //  构造函数
	MyException(){
		...
	}
    //  析构函数（虚函数）
	~MyException(){
		...
	}
    //  拷贝构造函数
	MyException(const MyException& rhs){
		...
	}
    //  what成员（虚函数）
	void what(){
		...
	}
};
```

+ bad_cast和bad_alloc定义了默认构造函数。  
+ runtime_error和logic_error没有默认构造函数，但有一个参数为字符数组或string对象的构造函数。这些实参提供关于错误的更多信息。  
+ 继承体系的第二层将exception划分为两个大类：运行时错误和逻辑错误。运行时错误指只有在程序运行时才能检测的错误（比如申请内存失败）。逻辑错误指我们可以在代码中发现的错误（比如数组越界）。

## 总结
> + 异常使我们能够将问题的检测和解决过程分离开来
> + 在C++中，我们可以通过抛出一条表达式来引发一个异常
> + 一个异常如果没有被捕获，则它将终止当前程序
> + 在栈展开的过程中如果退出了某个块，编译器将这个块创建的对象正确地销毁
> + 析构函数不应该抛出不能被它自身处理的异常
> + 抛出指针要求不能抛出一个指向局部对象的指针
> + 如果catch接受的异常和某个继承体系有关，最好将catch的参数定义成引用类型
> + 如果多个catch语句的类型之间存在着继承关系，我们应该把继承链最底端的类放在前面，最顶端的类放在后面
> + 我们可以使用空的throw语句将异常重新抛出，由更上一层的函数对应的处理模块进行捕获
> + 如果catch(...)与其他几个catch语句一同出现时，catch(...)必须在最后的位置
> + 处理构造函数初始值异常的唯一方法是将构造函数写出函数try语句块
> + 通常情况下，编译器不能也不必在编译时验证异常说明
> + noexcept有两层含义：跟在函数参数列表后面时表示异常说明符；当作为noexcept异常说明的bool实参出现时，它是一个运算符
> + 函数指针与该指针所指的函数必须有一致的异常说明，基类与派生类对应的虚函数必须有一致的异常说明
> + 继承体系的第二层将exception划分为两个大类：运行时错误和逻辑错误

# Reference
[1] <<C++ Primer>>  
[2] [为什么析构函数中不能抛出异常？](https://blog.csdn.net/weixin_43869898/article/details/106845786)