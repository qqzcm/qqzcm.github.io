---
title: 刷题笔记 —— 查询带键的排列
authors: fanventory
date: 2023-04-20 11:16:00 +0800
categories: [leetcode]
tags: [leetcode, Binary Index Tree]
---

# 树状数组
> 该问题题干比较绕，大概要求是在给定的排列P中找到queries[i]所处下标，然后修改P的排列顺序。因为顺序改变了，所以导致下标无法在O(1)时间内求得。本题一种巧妙的方法是用树状数组实现

<br>
<br>

## 题目
给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你根据以下规则处理所有待查项 queries[i]（从 i=0 到 i=queries.length-1）：

一开始，排列 P=[1,2,3,...,m]。
对于当前的 i ，请你找出待查项 queries[i] 在排列 P 中的位置（下标从 0 开始），然后将其从原位置移动到排列 P 的起始位置（即下标为 0 处）。注意， queries[i] 在 P 中的位置就是 queries[i] 的查询结果。
请你以数组形式返回待查数组  queries 的查询结果。


## 例子

#### 示例1
```
输入：queries = [3,1,2,1], m = 5
输出：[2,1,2,1] 
解释：待查数组 queries 处理如下：
对于 i=0: queries[i]=3, P=[1,2,3,4,5], 3 在 P 中的位置是 2，接着我们把 3 移动到 P 的起始位置，得到 P=[3,1,2,4,5] 。
对于 i=1: queries[i]=1, P=[3,1,2,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,3,2,4,5] 。 
对于 i=2: queries[i]=2, P=[1,3,2,4,5], 2 在 P 中的位置是 2，接着我们把 2 移动到 P 的起始位置，得到 P=[2,1,3,4,5] 。
对于 i=3: queries[i]=1, P=[2,1,3,4,5], 1 在 P 中的位置是 1，接着我们把 1 移动到 P 的起始位置，得到 P=[1,2,3,4,5] 。 
因此，返回的结果数组为 [2,1,2,1] 。   
```

#### 示例2
```
输入：queries = [4,1,2,2], m = 4
输出：[3,1,2,0]
```

#### 示例3
```
输入：queries = [7,5,5,8,3], m = 8
输出：[6,5,0,7,5]
```

## 条件
+ 1 <= m <= 10^3
+ 1 <= queries.length <= m
+ 1 <= queries[i] <= m

## 难点分析
该题最简单的方法是暴力法解决，用一个数组记录P元素对应的位置，然后将通过平移将当前数组移动到最前端。时间复杂度为O(MQ)，M为排列P的长度，Q为数组queries的长度。  
我们重点讲解第二种解法，它可以在O(log(M+Q))的时间内完成。这种解法需要用到树状数组的相关知识，树状数组是一种快速获得某范围内元素和的数据结构，相关知识我们放在下面的位置。  
我们发现求解每一个询问项queries[i]在排列P中的位置，等价于求解queries[i]前面有多少个元素。在方法一中，我们采用先从列表中「删除」这个数再将其「插入」数组首部的方法，导致时间复杂度为O(M)。但我们可以延长数组的长度，使每个询问项对应的元素插在前面的空位，这样就可以避免移动元素带来的开销。    
我们以示例1为例，对于排列 [1, 2, 3, 4, 5] 以及查询 [3, 1, 2, 1]，一开始的数组为：
```
_ _ _ _ 1 2 3 4 5
```

第一次查询3，3前面有2个数。随后将3移动到前面：  
```
_ _ _ 3 1 2 _ 4 5
```

第二次查询1，1前面有1个数。随后将1移动到前面：  
```
_ _ 1 3 _ 2 _ 4 5
```

第三次查询2，2前面有2个数。随后将2移动到前面：  
```
_ 2 1 3 _ _ _ 4 5
```

第四次查询1，1前面有1个数。随后将1移动到前面：
```
1 2 _ 3 _ _ _ 4 5
```

最后我们得到结果[2, 1, 2, 1]。现在我们的问题是怎么快速计算前面有多少个数。  
如果一个一个数，那时间会退化为O(MQ)。
而树状数组的作用恰好是计算范围内的元素之和，所以我们可以利用树状数组快速计算前面有多少个数字。

## 树状数组

#### 场景
给定一个数组a，需要执行w次修改和q次查询，其中修改是修改某一个元素的值，查询是查询某一个范围内元素值的和。  
这个场景下，如果我们用普通方法，修改的时间是O(1)，但是查询需要循环求和，时间复杂度为O(n)。  
如果我们使用前缀和优化，查询时间是O(1)，但是由于所有前缀和都要更新，修改的时间是O(n)。  
为了平衡查询和修改的时间，树状数组被提出来，它的查询和修改时间复杂度都为O(logN)。所以树状数组适合计算范围和，且需要进行修改的场景。

#### lowbit函数
在讲解树状数组前，先了解一下lowbit函数。  
lowbit函数的功能就是求某一个数的二进制表示中最低的一位1。比如，x = 6，对应二进制为110，那么最后一位1应该是010，所以lowbit(x)返回2(二进制为010)。

下面给出两种求解lowbit的代码：  
```c++
int lowbit(x) 
{	
    return x - (x & (x - 1));
}
```

```c++
int lowbit(x) 
{	
    return x & -x;  //  -x是x的补码
}
```

#### 核心思想
我们从二进制的角度出发，比如 n = 6，对应二进制为0110。既然树状数组的功能是求范围和，那我们将一个数看成几个区间累加的形式。我们可以表示为累加的形式0110 = 0100 + 0010。其中0100是lowbit(0100)的结果，0010是lowbit(0110)的结果。

所以树状数组的核心思想是将范围和看成几个区间相加的结果。那区间该怎么划定呢？答案是根据二进制的前缀和。我们举例说明：  
比如 n = 7，我们求解前7个元素的和。7对应的二进制是0111，根据前缀，我们可以把0111分成三个区间，0100、0110、0111。  
接下来，前7个元素的和为：S7=a1+a2+a3+a4+a5+a6+a7。  

![图片1](image/查询带键的排列_pic1.png)

如上图所示：
区间0111刚好表示7，对应a7的置。  
区间0110的的前缀是011，它在第二层，对应a5+a6。  
区间0100的的前缀是01，它在第三层，对应a1+a2+a3+a4。  

所以我们求解前7个元素的和时，根据二进制的前缀和划分区间，最后转换为S7=a[7]+a[6]+a[4]。而且由于前缀是相同的，我们可以用x-lowbit(x)来得到上一个前缀和对应的数。比如7-lowbit(7)=6，6-lowbit(6)=4，4-lowbit(4)=0。

<br>

接下来的问题是，如何让a[6]的值等于a5+a6呢？  
如上图所示，5(0101)+lowbit(5)=6，也就是如果我们在给数组赋值时，赋值a[5]后，也同样赋值给a[6]。当a[6]也完成赋值后，a[6]的值会被赋值两次，分别是a5+a6。这个过程同样可以用lowbit实现。  
但当我们继续调用公式6+lowbit(6)=8。我们可以发现8对应的是第四层的格子，而且8(1000)和5(0101)、6(0110)的前缀都不同。由于我们查询的时候是根据二进制前缀和来划分区间的，我们查询6(0110)时，由于前缀不同，不会将区间划分到8(1000)。从而在我们查询划分的区间，该区间对应的数(比如6)包含了该区间的和(a5+a6)。

最后，赋值6(00110)的时候，需要不断调用x+lowbit(x)往上赋值，比如赋值给8(01000)。因为前8项之和包括了6对应的值，而且6和8在更大范围内有相同的前缀和。

## 解法

#### 解法1：模拟过程
```c++
class Solution {
public:
    vector<int> processQueries(vector<int>& queries, int m) {
        vector<int> P(m + 1, 0);
        vector<int> res;
        for(int i = 1 ; i <= m ; i++){
            P[i] = i - 1;
        }
        
        for(int i = 0 ; i < queries.size() ; i++){
            for(int j = 0 ; j < P.size() ; j++){
                if(P[j] < P[queries[i]]){
                    P[j]++;
                }
            }
            res.emplace_back(P[queries[i]]);
            P[queries[i]] = 0;
        }
        return res;
    }
};
```

#### 解法2：树状数组
```c++
class Solution {
public:
    class BIT{
        vector<int> c; 
        int n;
    public:
        BIT(int _n):n(_n), c(_n + 1) { }

        int lowbit(int x){  //  求x二进制中最右的1
            return x & (-x);
        }

        int query(int x){   //  查询x及前面所有元素的和
            int ans = 0;
            while(x){
                ans += c[x];
                x -= lowbit(x);
            }
            return ans;
        }

        void update(int x, int y){  //  更新
            while(x <= n){
                c[x] += y;
                x += lowbit(x);
            }
        }
    };

    vector<int> processQueries(vector<int>& queries, int m) {
        const int n = queries.size();
        vector<int> pos(m + 1, 0);  //  记录P中每个元素的位置
        vector<int> res;
        BIT tree(m + n);            //  数组长度m+n+1

        for(int i = 1 ; i <= m ; i++){
            pos[i] = n + i;
            tree.update(n + i, 1);  //  置1，范围和表示范围内有几个元素
        }

        for(int i = 0 ; i < n ; i++){
            int& cur = pos[queries[i]]; //  获取当前元素的位置
            tree.update(cur, -1);       //  该位置上的元素置0，表示删除
            res.emplace_back(tree.query(cur));  //  查询前面有多少个元素
            cur = n - i;                //  当前元素移动到前面
            tree.update(cur, 1);        //  移动后，该位置上的元素置1，表示插入
        }
        return res;
    }
};
```


## Reference
[1] [查询带键的排列](https://leetcode.cn/problems/queries-on-a-permutation-with-key/)  
[2] [树状数组简单易懂的详解](https://blog.csdn.net/FlushHip/article/details/79165701)  