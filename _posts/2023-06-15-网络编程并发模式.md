---
title: 读书笔记 —— 网络编程_并发模式
authors: fanventory
date: 2023-06-15 17:01:00 +0800
categories: [Reading Notes, Linux高性能服务器编程]
tags: [C++, 并发模式, 半同步/半异步模式, 领导者/追随者模式]
---

# 半同步/半异步模式/半同步/半反应堆模式/领导者/追随者模式
> 本节介绍了网络编程设计中的两种并发模式：半同步/半异步模式和领导者/追随者模式。半同步/半异步模式是指同步线程用于处理客户逻辑，异步线程用于处理IO事件。它有一种变体：半同步/半反应堆模式。半同步/半反应堆模式中异步线程只有主线程，工作线程负责处理IO读写和业务逻辑，是同步线程。接着我们介绍了领导者/追随者模式，它是指多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。最后我们分别总结了半同步/半异步模式和领导者/追随者模式的缺点。

<br>
<br>

## 两种高效的并发模式
对于计算密集型程序，并发编程并没有优势，反而因为切换任务导致效率下降。但对服务器这种IO密集型程序，并发编程可以使IO被阻塞时，将CPU分配给其他线程或进程，从而提高CPU利用率和程序速度。  
接下来我们探讨网络编程的并发模式。并发模式是指IO处理单元和多个逻辑单元之间协调完成任务的方式。  
服务器上主要的并发模式有两种：半同步/半异步模式(half-sync/half-async)，领导者/追随者模式(Leader/Followers)

## 同步线程/异步线程

在IO模型中，同步和异步是指内核向应用程序通知的是何种IO事件(就绪事件还是完成事件)，以及谁来完成IO读写(内核还是应用程序)。  
而在并发模式中，同步是指程序按代码顺序执行；异步是指程序的执行需要由系统事件(比如中断、信号等)来驱动。

同步读操作如下图a所示，程序按照代码顺序执行，当执行read函数时被阻塞，直到读取完数据再继续往下执行。  
异步读操作如下图b所示，程序执行read操作时，会放弃cpu，处理其他任务，直到数据读取完毕。系统会向应用程序发送一个信号，程序接收到信号后再继续往下执行。它不是严格按照代码顺序的，而是被阻塞时交替使用cpu。  

![图片1](image/网络编程_并发模式_pic1.png)

我们将同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。  

优缺点：  
+ 异步线程执行率高，实时性强，但程序复杂，难以调试和扩展，不适合大量并发的情况。  
+ 同步线程效率低，实时性差，但逻辑简单。

对于服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，我们应该同时使用同步线程和异步线程来实现，即半同步/半异步模式。

## 半同步/半异步模式

在半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理IO事件。  
异步线程监听到客户请求后，将其封装成请求对象，并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取和处理该请求对象。  
下图总结了半同步/半异步模式的工作流程：  

![图片2](image/网络编程_并发模式_pic2.png)

## 半同步/半反应堆模式

半同步/半反应堆(half-sync/half-reactive)模式是半同步/半异步模式中的一种变体。  
+ 在半同步/半反应堆模式中，异步线程只有一个，即主线程，负责监听所有socket上的事件
+ 如果监听到socket上有可读事件发生，主线程接受该连接，然后往epoll内核事件表中注册该socket上的读写事件
+ 如果连接的socket上有读写事件发生，主线程将该socket插入请求队列中
+ 所有的工作线程都睡眠在请求队列上，当有任务到来时，它们通过竞争(比如申请互斥锁)获取任务的接管权

半同步/半反应堆模式的工作流程如下图所示：  

![图片3](image/网络编程_并发模式_pic3.png)

主线程插入请求队列的是就绪的连接socket，所以半同步/半反应堆模式采用了Reactor模式。该模式要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这也是该模式名称中half-reactive的含义。

> 半同步/半反应堆模式也可以使用模拟Proactor事件处理模式，即主线程完成数据的读写，然后将数据、任务类型等信息封装为一个任务对象，将其插入请求队列中。工作线程从请求队列中取得任务对象后，即可直接处理，无序执行读写操作。

<br>

半同步/半反应堆模式的缺点：  
+ 主线程和工作线程共享请求队列，都需要对请求队列加锁互斥访问，耗费CPU时间
+ 每个工作线程同一时间只能处理一个客户请求，如果客户数量较多，请求队列会堆积许多任务对象，客户端响应速度会越来越慢。如果增加工作线程，大量的工作线程切换会耗费大量CPU时间

<br>

针对上诉缺点，我们对半同步/半反应堆模式进行改进，使它的工作线程能同时处理多个客户连接，如下图所示：  

![图片4](image/网络编程_并发模式_pic4.png)

这种模式更加高效。主线程只负责监听socket，连接socket由工作线程来完成。当有新的连接到来时，主线程将该连接socket派发给某个工作线程，此后新socket上的任何IO操作都由被选中的工作线程来处理，直到客户关闭连接。  
主线程向工作线程派发socket最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把新socket上的读写事件注册到自己的epoll内核事件表中。  
由于每个线程(主线程和工作线程)都维护自己的事件循环，它们独立监听不同的事件，每个线程都工作在异步模式，所以它并非严格意义上的半同步/半异步模式。

## 领导者/追随者模式

领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。  
在任意时间点，程序仅有一个领导者线程，它负责监听IO事件；其他线程则是追随者，在线程池中处于休眠状态，等待成为新的领导者。如果当前领导者线程检测到IO事件，首先从线程池中推选出新的领导者线程，然后处理IO事件。此时新的领导者等待新的IO事件，原来的领导者处理IO事件，二者事件了并发。  

<br>

领导者/追随者模式包含以下几个组件：  
+ 句柄集(HandleSet)
+ 线程集(ThreadSet)
+ 事件处理器(EventHandler)
+ 具体的事件处理器(ConcreteEventHandler)

这些组件的关系如下图所示：  

![图片5](image/网络编程_并发模式_pic5.png)

1. 句柄集

句柄表示IO资源，在Linux中通常是一个文件描述符。句柄集管理众多句柄，它用wait_for_event方法来监听这些句柄上的IO事件，并将其中就绪的事件通知给领导者进程。领导者则调用绑定句柄上的事件处理器来处理事件。领导者将句柄和事件处理器的绑定是通过句柄集中的register_handle方法实现的

2. 线程集

线程集是所有工作线程的管理者，负责线程之间的同步，以及新领导者的推选。  
线程集中的线程在任一时间都处于下面三种状态之一：  
+ Leader: 线程当前处于领导者状态，负责等待句柄集上的IO事件
+ Processing: 线程正在处理事件。  
领导者检测到IO事件后，可以转义到Processing状态来处理事件，并调用promote_new_leader方法推选新的领导者。领导者也可以指定其他追随者来处理事件(Event Handoff)，此时领导者地位不变。当处于Processing状态的线程处理完事件后，如果当前线程中没有领导者，那它将成为新的领导者，否则它将转变为追随者。  
+ Follower: 当前线程处于追随者身份。  
可以通过调用线程集的join方法等待成为新的领导者，也可以被当前的领导者指定来处理新的任务。

这三种状态之间的转换关系如下图所示：  

![图片6](image/网络编程_并发模式_pic6.png)

> 由于领导者线程推选新的领导者和追随者等待成为新领导者者两个操作都需要修改线程集，所以线程集提供一个Synchronizer成员来同步这两个操作。

3. 事件处理器和具体的事件处理器

事件处理器通常包含一个或多个回调函数handle_event。这些回调函数用于处理事件对应的业务逻辑。事务处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器的回调函数。  
具体的事件处理器是事件处理器的派生类，它们必须重新实现基类的handle_event方法，以处理特定的任务。  

领导者/追随者模式的优缺点：  
+ 由于领导者线程自己监听IO事件并处理客户请求，所以不需要在线程之间传递数据，也不需要像半同步/半反应堆模式那样同步请求队列的访问
+ 但领导者/追随者模式仅支持一个事件源集合，所以无法让各个工作线程独立地管理多个客户连接


## 总结
> + 服务器上主要的并发模式有两种：半同步/半异步模式，领导者/追随者模式
> + 在半同步/半异步模式中，同步线程用于处理客户逻辑，异步线程用于处理IO事件
> + 半同步/半反应堆模式是半同步/半异步模式中的一种变体
> + 领导者/追随者模式是多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式
> + 领导者/追随者模式包含以下几个组件：句柄集、线程集、事件处理器、具体的事件处理器

# Reference
[1] 《深入解析高性能服务器编程》    