---
title: 读书笔记 —— IO复用_poll
authors: fanventory
date: 2023-06-26 19:31:00 +0800
categories: [Reading Notes, Linux高性能服务器编程]
tags: [C++, poll, IO复用]
---

# poll
> 本节讲解了IO复用的其中一种系统调用——poll。我们首先介绍了poll的API。它的就绪条件和select调用一样，所以我们不再过多阐述。在最后我们将三种IO复用技术进行比较。

<br>
<br>


## poll API

下面是poll的系统调用，功能和select类似，在指定时间内轮询一定数量的文件描述符，测试其中是否有就绪项，其函数定义如下：

```c++
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

参数和返回值：  
+ fds: 指定所有被监听的文件描述符，这些文件描述符会被监听可读、可写和异常等事件
+ nfds: 被监听事件集合的大小，其中nfds_t定义为：

```
typedef unsigned long int nfds_t;
```

+ timeout: 指定poll的超时值，单位是毫秒
    + 如果timeout设置为-1，则poll调用将永远阻塞，直到某个事件发生
    + 如果timeout设置为0，则poll调用会立即返回
+ 返回值: 根据超时情况或是否被信号中断，存在以下几种返回情况：
    + 成功返回就绪(可读、可写或异常)文件描述符的总数
    + 如果在超时时间内没有任何文件描述符就绪，则返回0
    + 失败返回-1，并设置errno
    + 如果poll在等待期间接收到信号，则立即返回-1，并设置errno位EINTR

fds参数的类型是pollfd结构体数组指针，pollfd结构体的定义如下：  

```c++
struct pollfd
{
    int fd;         //  文件描述符
    short events;    //  注册事件
    short revents;   //  实际发生的事件，由内核写入
};
```

pollfd结构体成员含义：  
+ fd: 指定文件描述符
+ events: 告诉poll监听fd上的哪些事件，它的值由一系列事件的按位或组成
+ revents: 由内核写入，用来通知应用程序fd实际发生了哪些事件

poll支持的事件类型如下表所示：  

| 事件 | 描述 | 是否可作为输入 | 是否可作为输出 |
| -- | -- | -- | -- |
| POLLIN | 数据(包括普通数据和优先数据)可读 | 是 | 是 |
| POLLRDNORM | 普通数据可读 | 是 | 是 |
| POLLRDBAND | 优先数据可读(Linux不支持) | 是 | 是 |
| POLLPRI | 高优先级数据可读，比如TCP带外数据 | 是 | 是 |
| POLLOUT | 数据(包括普通数据和优先数据)可写 | 是 | 是 |
| POLLWRNORM | 普通数据可写 | 是 | 是 |
| POLLWRBAND | 优先数据可写 | 是 | 是 |
| POLLRDHUP | TCP连接被对方关闭，或对方关闭写操作，它由GNU引入 | 是 | 是 |
| POLLERR | 错误 | 否 | 是 |
| POLLHUP | 挂起。比如管道写端被关闭后，读端描述符上将收到POLLHUP事件 | 否 | 是 |
| POLLNVAL | 文件描述符未打开 | 否 | 是 |

原本应用程序需要根据recv的返回值判断socket上接收的是有效数据还是关闭连接请求。但Linux内核2.6.17之后，GNU为poll系统调用增加了POLLRDHUP事件，用来区分接收的是有效数据还是关闭连接请求。但使用POLLRDHUP事件时，需要在代码最开始处定义_GNU_SOURCE。

## 三种IO复用函数的比较

我们从事件集、最大支持文件描述符、工作模式、具体实现四个方面比较三种IO复用函数的异同：  

<hr>
1. 事件集

相同之处:  
+ 这三种IO复用函数都是通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并且通过这些结构体变量对应的参数获取内核处理结果

不同之处：  
+ select的参数类型fd_set没有将文件描述符和事件绑定，而是通过三个类型的参数来区分可读、可写和异常事件的发生。一方面，这使select不能处理更多类型的事件，另一方面应用程序下次调用select前不得不重置这三个fd_set集合
+ poll的参数类型pollfd则将文件描述符和事件绑定在一起，并且内核每次修改的是结构体中的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数
+ epoll则是在内核中维护一个事件表，并提供epoll_ctl调用控制内核表，往内核事件表中添加、删除、修改事件。这样每次epoll_wait调用都可以直接从内核事件表中取得用户注册的事件，而无须反复传入这些事件。而且epoll_wait返回就绪的事件集，而select和poll返回所有的事件集，这使得epoll检索就绪文件描述符的时间更快

<hr>

2. 最大支持文件描述符

不同之处：  
+ poll和epoll_wait分别用nfds和maxevents参数指定最多监听多少个文件描述符和事件，这两个数值都能达到系统允许打开的最大文件描述符数目，即65535(/proc/sys/fs/file-max)
+ select允许监听的最大文件描述符数量通常由限制，虽然可以修改这个限制，但是可能使程序出现BUG

<hr>

3. 工作模式

不同之处：  
+ select和poll只能工作在相对低效的LT模式
+ epoll可以工作在高效的ET模式，该模式能进一步减少可读、可写和异常等事件被触发的次数

<hr>

4. 具体实现

不同之处：  
+ select和poll都采用轮询的方式，即每次调用都要扫描整个注册文件描述符集合，将其中就绪的文件描述符返回给应用程序
+ epoll_wait则采用回调的方式，内核检测到就绪文件描述符，将触发回调函数。回调函数会将该文件描述符上对应的事件插入内核就绪事件队列中，在恰当的时机将就绪事件队列中的内容拷贝到用户空间(但是活动连接比较多时，epoll_wait未必高效，因为回调函数过于频繁。所以epoll_wait适用于连接数量比较多，活动连接比较少的情况)

<hr>

最后我们通过一个表总结这三种IO复用函数的区别：  

| 系统调用 | select | poll | epoll |
| -- | -- | -- | -- |
| 事件集合 | 用户通过3个参数分别传入感兴趣的可读、可写和异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。这使得用户每次调用select都要重置这3个参数 | 统一处理所有事件类型，因此只需要一个事件集参数，用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件 | 内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll_wait时，无须反复传入事件集。epoll_wait系统调用的参数events仅用于反馈就绪的事件 |
| 应用程序索引就绪文件描述符的时间复杂度 | O(n) | O(n) | O(1) |
| 最大支持文件描述符数量 | 有最大值限制 | 65535 | 65535 |
| 工作模式 | LT | LT | LT & ET |
| 内核实现和工作效率 | 采用轮询方式来检测就绪事件，算法时间复杂度为O(n) | 采用轮询方式来检测就绪事件，算法时间复杂度为O(n) | 采用回调方式来检测就绪算法，算法时间复杂度为O(1) |

## 总结
> + 操作系统提供了poll的系统调用，功能是在指定时间内轮询一定数量的文件描述符，测试其中是否有就绪项

# Reference
[1] 《深入解析高性能服务器编程》    