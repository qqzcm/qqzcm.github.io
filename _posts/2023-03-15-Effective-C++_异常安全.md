---
title: 读书笔记 —— Effective C++ (异常安全)
authors: fanventory
date: 2023-03-15 15:16:00 +0800
categories: [Reading Notes,Effective C++]
tags: [C++, Reading Notes]
---

> 本节中我们探讨异常安全代码，首先我们通过一个例子指出这个例子中存在的异常不安全行为。在解决这些行为之前，我们先认识一下异常安全保证的等级。这很重要，因为我们需要根据选择的异常安全保证来解决例子中的问题。通常的解决方法有调换代码逻辑顺序，用智能指针管理对象。接着我们提出了一般化的异常安全代码设计策略，copy-and-swap。最后我们强调了并不是任何代码都可以改写成异常安全的，首先是异常安全代码需要时间和空间成本，这些成本可能在现实场景中无法满足。其次，一个函数的异常安全等级由它内部调用子函数的最低异常安全等级决定。所以当我们设计一个异常安全系统的时候，应该仔细斟酌它需要提供什么样的异常安全保证，然后在现实可行的情况下，尽量去实现最强烈的异常安全保证。

<br>
<br>

# 异常安全
异常安全在编程中十分重要，它指的是我们的程序哪怕出现了异常，也能处于某种安全状态，而不是某种不确定的状态。先让我们来看一个例子：  
```c++
//  修改背景的函数
void PrettyMenu::changeBackground(istream& imgSrc){
    lock(&mutex);               //  上锁
    delete bgImage;             //  删除旧的背景图
    ++imageChanges;             //  背景图计数器加一
    bgImage=new Image(imgSrc);  //  安装新的背景图
    unlock(&mutex);             //  解锁
}
```

这个函数功能很简单，但是它是异常不安全的。异常安全性有两个条件，我们从这两个条件来阐述这个函数为什么是不符合异常安全的。  
1. 不泄露任何资源。如果lock之后的某一步发生了异常，因为发生异常后，后面的代码都不会执行，所以unlock自然也不会执行。这就导致了程序互斥器并没有解锁，也就是发生了资源泄漏。

2. 不允许数据败坏。如果我们新的背景图安装失败，旧的背景图删除了，所以程序会处于没有背景图的状态。另外，背景图计数器加一，但是背景图并没有成功安装，这就导致了数据败坏。

# 异常安全级别
在探讨解决方法之前，我们先来了解一下异常安全函数的三个等级（或者说提供的三个保证）。然后我们根据实际情况，为函数提供相应的异常安全级别。  
1. 基本承诺  
如果异常被抛出，程序内的任何事物仍然保持在有效状态下。就像上面的changeBackground函数，如果该函数抛出异常，我们承诺它的背景图仍然是有效的。但是它提供了一个最基本的承诺，也就是说，虽然背景图仍然可以显示，但我们无法确定当前显示的背景图是新的背景图还是旧的背景图，抑或是某个缺省背景图。

2. 强烈保证  
如果异常被抛出，程序状态保持不变。就像数据库的一致性，如果函数成功，则完全成功；如果函数失败，则退回到调用函数前的状态。

3. 不抛掷保证（nothrow）  
承诺绝不抛出异常，因为它们总能够完成原先承诺的功能。这是最高级别的保证，比如内置类型（int，指针）身上的所有操作都是提供nothrow保证的。

> 这里需要注意，承诺nothrow并不是指函数中声明了nothrow。C++中函数可以声明nothrow，承诺函数不会抛出异常，但这只是一个虚幻的承诺，是否抛出异常由函数的实现决定，而不是nothrow声明决定。如果声明了nothrow的函数抛出异常，异常行为由set_unexpected设置的行为（exit或abort）决定$^{[3]}$。  
> ```c++
> int doSomething() nothrow;    //  声明不抛出异常，不代表真的不会抛出异常
> int doSomething() throw();    //  声明不抛出异常的另一种写法
> 
> ```

任何异常安全的代码都需要提供上述三种保证之，否则它就不具备异常安全性。所以如果我们需要把代码写成异常安全的，首先需要思考为我们的函数提供哪一种安全保证。  
当然，最强烈的异常保证（不会抛出任何异常）肯定是最好的，但是现实中很难做到。比如所有STL容器，申请动态内存空间时，都可能抛出bad_alloc异常。所以，可能的话请提供nothrow保证。但是对于大多数函数而言，抉择往往落在基本保证和强烈保证之间。

<br>

现在让我们回到changeBackground函数，并将它改造为异常安全的。首先我们尝试为该函数提供强烈保证。  
1. 针对第一个问题，lock之后发生异常会泄漏内存，unlock函数并没有执行，我们用智能指针来指向互斥器。在delete bgImage时，也可能因为发生异常，而导致内存泄漏，我们同样使用智能指针来管理。智能指针管理的内存，无论是否发生异常，当运行到代码块的末端时，都会执行释放内存操作。  
```c++
//  这里我们定义一个类来封装互斥器操作
class Lock{     
public:
    explicit Lock(Mutex* pm): MutexPtr(pm,unlock)   //  传递unlock函数给删除器
    {
        lock(MutexPtr.get());   //  构造函数中上锁
    }
private:
    std::tr1::shared_ptr<Mutex> MutexPtr;
};

//  改造后的changBackground函数
void PrettyMenu::changeBackground(istream& imgSrc){
    Lock m1(&mutex);            //  上锁，运行结束能自动解锁
    delete bgImage;             //  删除旧的背景图
    ++imageChanges;             //  背景图计数器加一
    bgImage=new Image(imgSrc);  //  安装新的背景图
}
```

2. 针对第二个问题，数据败坏——例如安装新的背景图失败，计数器却完成了加一操作，我们调换一下语句顺序。只有新的背景图安装完成，计数器才能加一。这样提供了强烈保证——新背景图安装成功，计数器加一；安装失败，则计数器和调用前状态一致。  
对于另一个问题：新的背景图安装失败，但是旧的背景图早已经被删除，我们同样调换一下顺序，先创建Image对象，再完成删除操作。如果Image对象创建失败，则原来的背景图没有被delete，程序保持原来的背景图；如果创建成功，那就用新的背景图替换旧的背景图。这样就能为changeBackground函数提供强烈保证。这里我们采用智能指针管理bgImage成员。

```c++
//  修改原来的类中，背景图bgImage的存储方式
class PrettyMenu{
    ...
    std::tr1::shared_ptr<Image> bgImage;    //  用智能指针管理对象
    ...
};

//  改造后的changBackground函数
void PrettyMenu::changeBackground(istream& imgSrc){
    Lock m1(&mutex);                    //  上锁，运行结束能自动解锁
    bgImage.reset(new Image(imgSrc));   //  替换背景图
    ++imageChanges;                     //  先替换背景图，再修改计数器
}
```

注意，这里不需要手动delete原来的背景图，因为这个动作已经由智能指针内部完成了。删除动作只会发生在new Image(imgSrc)动作完成之后，也就是说new Image(imgSrc)执行成功了，才会替换和删除背景图。如果系统未进入reset函数，也绝不会使用delete。所以，改造后的changBackground函数调用前后状态能保持一致。  


但是改造后的函数还有一点美中不足：我们传入参数的是一个输入流istream，如果Image构造函数抛出异常，该输入流的读取记号(read marker)已被移走。也就是说对于程序的其他部分，输入流istream发生了变化，调用前和调用后的参数状态不一致。我们只要改变参数类型（由引用改为传值），或者传入图像数据的名称就可以解决这个问题。

# copy and sawp策略
接下来我们提供一种一般化的设计策略来提供强烈保证，这个策略叫做copy and swap。它的原则是：我们生成一个副本，然后对这个副本进行修改。如果修改时抛出异常，由于原对象没有任何修改，所以原对象还是修改前的状态；如果修改成功，我们将原对象和副本进行交换。这里的swap置换函数必须不抛出异常，当然着很容易实现（我们上面说了，交换内置类型和指针，往往可以保证不抛出异常）。  
就像下面这样：  
```c++
//  这里将原来的类改造为pimpl idiom结构，便于我们高效地实现swap
struct PMImpl{  //  struct和class区别不大，struct更适合看成一个数据结构，class更适合看成一个对象
    std::tr1::shared_ptr<Image> bgImage;
    int imageChanges;
};
class prettyMenu{
    ...
private:
    Mutex mutex;
    std::tr1::shared_ptr<PMImpl> pImpl;
};
//  改造后的changBackground函数
void PrettyMenu::changeBackground(istream& imgSrc){
    using std::swap;
    Lock m1(&mutex);                    //  上锁，运行结束能自动解锁
    //  创建副本
    std::tr1::shared_ptr<PMImpl> pNew(new PMImpl(*pImpl));
    //  修改副本
    pNew->bgImage.reset(new Image(imgSrc));
    ++pNew->imageChanges;
    //  置换副本
    swap(pImpl, pNew);
}
```

`copy and swap`策略是使对象状态全部实现或者全部不实现的一种很好的办法。但是它也存在一些问题。
1. 首先它并不总能保证整个函数是强烈异常安全的。我们来看下面这个例子：  
```c++
void someFunc(){
    ...
    f1();
    f2();
    ...
}
```

f1和f2函数都是强烈异常安全的，如果f1成功执行，f2随后抛出了异常，那么此时程序状态和someFunc被调用前的程序状态不同。  
这是由于连带影响(side effects)。如果函数只操作局部性状态(local state)，则很容易提供强烈保证。但是如果函数对非局部性数据(non-local state)进行操作时，提供强烈保证就困难多了。
举个例子，比如f1修改了数据库某个字段，f2抛出了异常，那么没有什么做法可以使数据库操作取消和恢复。

2. 为每一个数据复制一个副本，然后进行置换，这种做法比原来的做法需要更多的时间和空间成本。现实中，效率和复杂性带来的成本可能使我们不能提供强烈保证。  
例如在一个对时间要求很高，且数据结构较大的系统中，复制和置换的成本是我们不能接受的，这时候我们只能退而求其次，提供基本保证。

# 不存在局部异常安全
继续看刚刚的someFunc函数代码，如果f2无法提供异常安全性，那么someFunc函数甚至无法提供最基本的保证。因为一旦f2抛出异常，程序有可能在f2内泄漏资源，或者败坏数据。someFunc函数无法在外层调用解决这些问题。也就是说如果someFunc调用的函数无法提供任何异常安全保证，那么someFunc自身也无法提供任何保证。  
所以一个软件系统要不具有异常安全性，要不就不具有异常安全性，没有所谓的局部异常安全性。

<br>

最后我们应该挑选“现实可实施”条件下最强的异常安全等级。
借用书中的一段话来结尾：  
四十年前，满载goto的代码被视为一种美好实践，而今我们却致力写出结构化控制流(structred control flows)。二十年前，全局数据(globally accessible data)被视为一种美好实践，而今我们却致力于数据的封装。十年前，撰写“未将异常考虑在内”的函数被视为一种美好实践，而今我们致力于写出“异常安全码”。


## 总结
> + 较少的代码更好，这意味着出错的机会更少，而且一旦修改，被误解的机会也更少
> + 异常安全函数即使发生异常也不会造成资源泄漏和数据败坏，这样的函数分为三种可能的保证：基本型、强烈型、不抛出异常型
> + 强烈保证往往可以用copy-and-swap实现，但是强烈保证的函数并非对所有很多都可实现或具备现实意义
> + 函数提供的异常安全保证由其所调用的各个函数决定，最高的异常保证性取决于调用函数中的异常安全保证的最弱者

# Reference
[1] <<Effective C++>>  
[2] <<C++ Primer>>  
[3] [std::set_terminate 和 std::set_unexpected](http://events.jianshu.io/p/867ddb5c7ac3)    
[4] [c++ 中 class 和 struct 的区别是什么](https://blog.csdn.net/wjw7869/article/details/50602648)