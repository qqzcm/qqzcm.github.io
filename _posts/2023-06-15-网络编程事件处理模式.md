---
title: 读书笔记 —— 网络编程_事件处理模式
authors: fanventory
date: 2023-06-15 15:49:00 +0800
categories: [Reading Notes, Linux高性能服务器编程]
tags: [C++, Reactor, Proactor]
---

# Reactor/Proactor
> 本节介绍了网络编程中两种高效的事件处理模式：Reactor模式和Proactor模式。同步IO模型通常用于Reactor模式，异步IO模型通常用于Proactor模式。但同步IO模型也能模拟出Proactor模式。Reactor模式指主线程只负责监听文件描述符是否有事件发生，其他实质性的工作，比如读写数据、业务处理都交给工作线程负责。而Proactor模式中主线程除了负责监听socket事件的发生，还负责所有的数据读写。而工作线程只负责业务逻辑。

<br>
<br>

## 两种高效的事件处理模式
网络设计模式中有两种高效的事件处理模式：Reactor模式和Proactor模式。   
同步IO模型通常用于Reactor模式，异步IO模型通常用于Proactor模式。当然，同步IO模型也能模拟Proactor模式。  
接下来我们围绕这两种事件处理模式进行探讨。

## Reactor模式

Reactor模式指主线程(IO处理单元)只负责监听文件描述符是否有事件发生，如果事件发生则通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作(比如读写数据，接收新的连接，处理客户请求)，这些实质性工作均在工作线程中完成。

同步IO模型使用Reactor模式的工作流程如下图所示(以epoll_wait为例)：  

![图片1](image/网络编程_事件处理模式_pic1.png)

+ 主线程向epoll内核事件表中注册socket上的读就绪事件
+ 主线程调用epoll_wai等待socket上有数据可读
+ 当socket上有数据可读时，epoll_wait通知主线程，主线程将socket可读事件放入请求队列
+ 睡眠在请求队列上的某个工作线程被唤醒，从socket中读取数据，并处理客户请求
+ 工作线程向epoll内核事件表中注册该socket上的写就绪事件
+ 主线程调用epoll_wai等待socket可写
+ 当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列
+ 睡眠在请求队列上的某个工作线程被唤醒，它往socket中写入服务器处理客户请求的结果

> 工作线程从请求队列中取出事件后，会根据事件的类型处理它，对于可读事件，执行读数据和处理请求的操作；对于可写事件，执行写数据的操作。这里不会区分读工作线程和写工作线程。

## Proactor模式

Proactor模式模式是将所有的IO操作都交给主线程和内存来处理，工作线程只负责业务逻辑。  

异步IO模型使用Proactor模式的工作流程如下图所示(以aio_read和aio_write为例)：  

![图片2](image/网络编程_事件处理模式_pic2.png)

+ 主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序
+ 主线程继续处理其他逻辑
+ 当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用
+ 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求
+ 工作线程处理完客户请求后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序
+ 主程序继续处理其他逻辑
+ 当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据以及发送完毕
+ 应用程序预先定义好的信号处理函数选择一个工作线程来进行善后处理，比如决定是否关闭socket

> 图中连接socket的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接在socket上的读写事件。主线程中的epoll_wait调用仅仅用来监听socket上的连接请求事件，而不用来检测连接socket上的读写事件。

## 同步IO模型模拟Proactor模式

同步IO模型模拟Proactor模式的原理是：主线程执行数据的读写操作，在读写完成后，主线程向工作线程通知这一完成事件。工作线程直接获得了数据读写的结果，只需要对读写结果进行逻辑处理。

同步IO模型模拟Proactor模式的工作流程如下图所示(以epoll_wait为例)：  

![图片3](image/网络编程_事件处理模式_pic3.png)

+ 主线程向epoll内核事件表中注册socket上的读就绪事件
+ 主线程调用epoll_wai等待socket上有数据可读
+ 当socket上有数据可读时，epoll_wait通知主线程。主线程从socket中循环读取数据，然后把读取到的数据封装成一个请求对象插入请求队列中
+ 睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求
+ 工作线程向epoll内核事件表中注册该socket上的写就绪事件
+ 主线程调用epoll_wai等待socket可写
+ 当socket可写时，epoll_wait通知主线程，主线程往socket上写入服务器处理客户请求的结果

## 总结
> + 网络设计模式中有两种高效的事件处理模式：Reactor模式和Proactor模式
> + 同步IO模型通常用于Reactor模式，异步IO模型通常用于Proactor模式。同步IO模型也能模拟Proactor模式
> + Reactor模式指主线程(IO处理单元)只负责监听文件描述符是否有事件发生，如果事件发生则通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作(比如读写数据，接收新的连接，处理客户请求)，这些实质性工作均在工作线程中完成
> + Proactor模式模式是将所有的IO操作都交给主线程和内存来处理，工作线程只负责业务逻辑
> + 同步IO模型模拟Proactor模式的原理是：主线程执行数据的读写操作，在读写完成后，主线程向工作线程通知这一完成事件。工作线程直接获得了数据读写的结果，只需要对读写结果进行逻辑处理

# Reference
[1] 《深入解析高性能服务器编程》    