---
title: 刷题笔记 —— 找出游戏的获胜者
authors: fanventory
date: 2023-04-27 19:58:00 +0800
categories: [leetcode]
tags: [leetcode, Queue, Formula]
---

# 队列/递推公式
> 该问题是著名的约瑟夫环问题，我们可以通过队列来模拟，也可以通过递推公式来得到结果。

<br>
<br>

## 题目
共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 <= i < n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。

游戏遵循如下规则：

从第 1 名小伙伴所在位置 开始 。  
沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。  
你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。  
如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。  
否则，圈子中最后一名小伙伴赢得游戏。  
给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。

## 例子

#### 示例1
```
输入：n = 5, k = 2
输出：3
解释：游戏运行步骤如下：
(1) 从小伙伴 1 开始。
(2) 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。
(3) 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。
(4) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。
(5) 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。
(6) 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。
(7) 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。
(8) 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。
(9) 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。
```

#### 示例2
```
输入：n = 6, k = 5
输出：1
解释：小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。
```

## 条件
+ 1 <= k <= n <= 500

## 难点分析
该题最简单的方法是采用循环队列进行模拟，直到最后一个人存活。  
其实这个问题是著名的约瑟夫环问题，最后的存活者是可以根据规律推导出来的。下面我们一步步推导出这个公式。  

我们假设有11个人轮流报数，报到3的人被淘汰，过程如下图所示：  

![图片1](image/找出游戏的获胜者_pic1.png)

+ 第一轮：队头是1号，报数轮到3号，3号被淘汰
+ 第二轮：队头是4号，报数轮到6号，6号被淘汰
+ 第三轮：队头是7号，报数轮到9号，9号被淘汰
+ ...
+ 第九轮：队头是2号，报数轮到2号，2号被淘汰
+ 最后存活者是7号

根据上图我们可以发现一个规律，如果报数到3号被淘汰，那第二轮队头就是4，所以人的下标都会往前移动3位。  
也就是说，当前有11个人，如果下标为6的（编号为7）是最后的存活者，那下一轮10个人时，它的下标应该是3。因为编号为3的人淘汰了，编号为4的人变成队头，所以人对应下标都往前移动3位。  
那反过来，如果当前有10个人，最后的存活者下标为3，那上一轮11人，该存活者的下标为多少呢？答案是6，我们把被淘汰的第3个人补回来，那所有人的下标都要往后移动3位。位于最后的两个人需要移动到队头去，所以我们模上当前人数。  
现在我们把问题一般化，如果有n-1个人，最后的存活者下标为f(n-1,M)。那上一轮n个人，也就是需要把所有人的下标都往后移动m位，然后模n。也就是说该存活者下标为 f(n,m)= ( f(n-1,m) + m )% n。

现在我们从头推起  
最后一轮，只剩最后一个人，那他就是存活者，即：  
+ f(1,3) = 0  
倒数第二轮，还剩两个人，存活者的下标为：    
+ f(2,3) = (f(1,3) + 3) % 2  
倒数第三轮，还剩三个人，存活者的下标为：   
+ f(3,3) = (f(2,3) + 3) % 3  
...  

以此类推，我们得到递推公式：  
f(n,m)= ( f(n-1,m) + m )% n


## 解法

#### 解法1：队列
```c++
class Solution {
public:
    int findTheWinner(int n, int k) {
        int *arr = new int[n];
        for(int i = 0 ; i < n ; i++){
            arr[i] = i + 1;
        }
        //   life为当前生存人数，next为当前队首下标
        int life = n, next = 0;    
        while(life != 1){
            int t = (next + k - 1) % life;
            for(int i = t + 1 ; i < life ; i++){
                arr[i - 1] = arr[i];
            }
            life--;
            next = t  % life;
        }
        return arr[0];
    }
};
```

#### 解法2：递推公式
```c++
class Solution {
public:
    int findTheWinner(int n, int k) {
        int p = 0;
        for (int i = 2 ; i <= n ; i++){
            p = (p + k) % i;
        }
        return p + 1;
    }
};
```

## Reference
[1] [找出游戏的获胜者](https://leetcode.cn/problems/find-the-winner-of-the-circular-game/submissions/)   
[2] [约瑟夫环——公式法（递推公式）](https://blog.csdn.net/u011500062/article/details/72855826)